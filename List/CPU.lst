C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE CPU
OBJECT MODULE PLACED IN .\Output\CPU.obj
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE CPU.c LARGE OPTIMIZE(9,SPEED) REGFILE(.\Output\TW8835_REV31.ORC) BROWSE MOD
                    -DP2 DEFINE(EVB_30,EVB_31,nullFn=//) DEBUG OBJECTEXTEND CODE SYMBOLS PRINT(.\List\CPU.lst) OBJECT(.\Output\CPU.obj)

line level    source

   1          /**
   2           * @file
   3           * CPU.c 
   4           * @author Harry Han
   5           * @author YoungHwan Bae
   6           * @author Brian Kang
   7           * @version 1.0
   8           * @section LICENSE
   9           *      Copyright (C) 2011~2012 Intersil Corporation
  10           * @section DESCRIPTION
  11           *      8051 MCU file
  12           *
  13          */
  14          #include "config.h"
  15          #include "reg.h"
  16          #include "typedefs.h"
  17          #include "TW8835.h"
  18          #ifdef SUPPORT_HDMI_SiIRX
              #include <hal_cp9223.h>
              #include <SiI_config.h>
              #endif
  22          
  23          #include "printf.h"
  24          #include "I2C.h"
  25          #include "CPU.h"
  26          #include "Remo.h"
  27          #include "TouchKey.h"
  28          
  29          
  30          //===== Timer =======
  31          DATA    BYTE    tic01=0;                                //unit 1msec
  32          DATA    WORD    tic_pc=0;
  33          DATA    WORD    tic_task=0;
  34          DATA    DWORD   SystemClock=0L;                 //unit 10msec
  35          DATA    DWORD   OsdTimerClock=0L;
  36          
  37          DATA    WORD    RemoTic=0;
  38          #if defined(SUPPORT_I2CCMD_TEST_SLAVE)
              DATA    WORD    ext_i2c_timer;
              #endif
  41          
  42          //===== WatchDog ======
  43          #ifdef DEBUG_WATCHDOG
                              bit             F_watch=0;
              #endif
  46          
  47          //===== Serial0 ======
  48          DATA    BYTE    RS_buf[RS_BUF_MAX];
  49          DATA    BYTE    RS_in, RS_out;
  50                          bit             RS_Xbusy=0;
  51                          bit             RS0_Xbusy=0;
  52          //===== Serial1 ======
  53          #ifdef SUPPORT_UART1
              XDATA   BYTE    RS1_buf[RS_BUF_MAX];
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 2   

              DATA    BYTE    RS1_in, RS1_out;
                              bit             RS1_Xbusy=0;
              #endif
  58          
  59          //===== Remo ========
  60          #define REMO_IN P1_2
  61          
  62          #ifdef REMO_RC5
  63                  bit         RemoPhase1, RemoPhase2;
  64                  IDATA BYTE      RemoDataReady=0;
  65                  IDATA BYTE  RemoSystemCode, RemoDataCode;
  66                  IDATA DWORD RemoReceivedTime;
  67          #ifdef DEBUG_REMO
                      IDATA BYTE  RemoSystemCode0, RemoDataCode0;
                      IDATA BYTE  RemoSystemCode1, RemoDataCode1;
                      IDATA BYTE  RemoSystemCode2, RemoDataCode2;
                      IDATA BYTE  RemoCaptureDisable=0;
              #endif
  73          #elif defined REMO_NEC
                      bit                     RemoPhase=0;
                      DATA BYTE       RemoStep=0;
                      DATA BYTE       RemoHcnt, RemoLcnt;
                      DATA BYTE       RemoData[4];
                  IDATA BYTE  RemoDataReady=0;
                      IDATA BYTE  RemoNum, RemoBit;
              #ifdef DEBUG_REMO_NEC
                      DATA BYTE       DebugRemoStep;
                      DATA BYTE       DebugRemoHcnt;
                      DATA BYTE   DebugRemoLcnt;
                      DATA BYTE   DebugRemoNum;
                      DATA BYTE   DebugRemoBit;
                      DATA BYTE   DebugRemoPhase;
                      DATA BYTE   DebugRemoDataReady;
              #endif
              
              #endif // REMO 
  91                          bit             RM_get = 0;
  92          
  93          //===== memory register ========
  94          
  95          volatile BYTE   XDATA *DATA regTW88 = REG_START_ADDRESS;
  96          
  97          //===== interrupt status ========
  98          
  99          DATA    BYTE    INT_STATUS=0;
 100          DATA    BYTE    INT_STATUS2=0;
 101          DATA    BYTE    INT_STATUS3=0;  //for debug ext4_intr
 102          DATA    BYTE    INT_STATUS_ACC=0;
 103          DATA    BYTE    INT_STATUS2_ACC=0;
 104          DATA    BYTE    EXINT_STATUS = 0;
 105          DATA    WORD    MCU_INT_STATUS=0;
 106          DATA    WORD    VH_Loss_Changed=0;
 107          
 108          
 109          #ifdef SW_I2C_SLAVE
              //===== I2C Software Slave ========
              DATA BYTE sw_i2c_index=0;
              DATA BYTE sw_i2c_data;
              DATA BYTE sw_i2c_devid;         //0:NotMine, 1:MasterWrite, 2:MasterRead
              DATA BYTE sw_i2c_regidx;
              BYTE dbg_sw_i2c_sda_count;              //debug
              WORD dbg_sw_i2c_scl_count;              //debug
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 3   

              BYTE dbg_sw_i2c_index[10]; //
              BYTE dbg_sw_i2c_devid[10];
              BYTE dbg_sw_i2c_regidx[10];
              BYTE dbg_sw_i2c_data[10];
              #define SW_I2C_SCL              P1_6
              #define SW_I2C_SDA              P1_7
              #define SW_I2C_SLAVE_ID_W       0x8C
              #define SW_I2C_SLAVE_ID_R       0x8D
              
              #define EINT_SW_I2C_SCL_NUM             6
              #define EINT_SW_I2C_SCL_MASK    0x40
              
              #define I2C_SCL_WAIT_RISING             E2IT |=  EINT_SW_I2C_SCL_MASK
              #define I2C_SCL_WAIT_FALLING    E2IT &= ~EINT_SW_I2C_SCL_MASK
              
              #define I2C_SCL_CLEAR_INTR_FLAG         E2IF  = 0x40
              #define I2C_SCL_ENABLE_INTR                     E2IE |= 0x40
              #define I2C_SCL_DISABLE_INTR            E2IE &= ~0x40                   
              #endif
 136          
 137          DWORD IntCount = 0;
 138          
 139          
 140          //==========================
 141          // PROTOTYPE for Internal 
 142          //==========================
 143          void InitRemoTimer(void);
 144          
 145          
 146          //*****************************************************************************
 147          //*      Ext Int 0 Interrupt (Low / Falling)    (Internal)      : <<Chip Status>>       P2.0
 148          //*****************************************************************************
 149          #ifdef MODEL_TW8835_EXTI2C
              /**
              * chip interrupt service routine
              */
              void    ext0_int(void) interrupt 0 using 1
              {
              SFR_EX0=0;
              #ifdef DEBUG_ISR
                      MCU_INT_STATUS |= 0x0001;
              #endif
              SFR_EX0=1;
              }
              /**
                      Pseudo ext0_int
              */
              void Ext0PseudoISR(void)
              {
                      DECLARE_LOCAL_page
              
                      ReadTW88Page(page);
                      WriteTW88Page(0);
              
                      INT_STATUS = ReadTW88(REG002);
                      WriteTW88(REG002, INT_STATUS & 0xFF);           //clear 
                      INT_STATUS2 = ReadTW88(REG004);
                      WriteTW88(REG004, INT_STATUS2 & 0x07);          //clear
              
                      if(INT_STATUS & 0x02)                                           //keep 0x02.
                              VH_Loss_Changed++;
              
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 4   

                      INT_STATUS_ACC |= INT_STATUS;
                      INT_STATUS2_ACC |= INT_STATUS2;
              
                      WriteTW88Page(page);
              
                      if(INT_STATUS & 0x02) {
                              //Printf("\n$$eint10_intr_count:%bd",eint10_intr_count);
                              Printf("\nExt0PseudoISR R002:%02bx R004:%02bx",INT_STATUS,INT_STATUS2);
                              if(INT_STATUS2 & 0x01)  Printf(" VLOSS");
                              else                                    Printf(" VFound");
                      }
              }
              #else //..MODEL_TW8835_EXTI2C
 192          /**
 193          * chip interrupt service routine
 194          */
 195          void ext0_int(void) interrupt 0 using 1
 196          {
 197   1              DECLARE_LOCAL_page
 198   1      
 199   1      SFR_EX0=0;
 200   1      #ifdef DEBUG_ISR
                      MCU_INT_STATUS |= 0x0001;
              #endif
 203   1      
 204   1              ReadTW88Page(page);
 205   1              WriteTW88Page(0);
 206   1      
 207   1      #ifdef MODEL_TW8836
                      INT_STATUS = ReadTW88(REG002) & 0xEF;
                      WriteTW88(REG002, INT_STATUS );         //clear 
              #else
 211   1              INT_STATUS = ReadTW88(REG002);
 212   1              WriteTW88(REG002, INT_STATUS & 0xFF);           //clear 
 213   1      #endif
 214   1              INT_STATUS2 = ReadTW88(REG004);
 215   1              WriteTW88(REG004, INT_STATUS2 & 0x07);          //clear
 216   1      
 217   1              if(INT_STATUS & 0x02)                                           //keep 0x02.
 218   1                      VH_Loss_Changed++;
 219   1      
 220   1              INT_STATUS_ACC |= INT_STATUS;
 221   1              INT_STATUS2_ACC |= INT_STATUS2;
 222   1      
 223   1              WriteTW88Page(page);
 224   1      
 225   1      SFR_EX0=1;
 226   1      }
 227          #endif //..MODEL_TW8835_EXTI2C
 228          
 229          
 230          //*****************************************************************************
 231          //*      Timer 0 Interrupt                                                                      : <<System Timer>>                                               
 232          //*****************************************************************************
 233          //      1 msec timer tic
 234          //  use 10us @27Mhz
 235          
 236          #ifdef SUPPORT_HDMI_SiIRX
              //------------------------------------------------------------------------------
              // Array of timer values
              //------------------------------------------------------------------------------
              static uint16_t TimerArray[CONF__TIMER_COUNT];
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 5   

              
              static uint16_t wTickCnt = 0;
              //------------------------------------------------------------------------------
              // Function: TIMER_GetTickCounter
              // Description: Gets tick counter ( 1 tick 570MS )
              //------------------------------------------------------------------------------
              uint16_t TIMER_GetTickCounter( void ){
              uint16_t rv;
              
                  SFR_TR0 = 0;        // stop timer tick
                  rv = wTickCnt;
                  SFR_TR0 = 1;        // start timer tick
                  return rv;
              }
              #endif
 256          
 257          #ifdef SW_I2C_SLAVE
              DATA BYTE sw_i2c_index_old;
              #endif
 260          
 261          /**
 262          * timer0 interrupt service routine
 263          */
 264          void timer0_int(void) interrupt 1 using 1
 265          {
 266   1      #ifdef SUPPORT_HDMI_SiIRX
                  uint8_t i;
              #endif
 269   1      
 270   1              SFR_ET0=0;
 271   1      #ifdef DEBUG_ISR
                      MCU_INT_STATUS |= 0x0002;
              #endif
 274   1              tic01++;
 275   1      
 276   1              tic01 %= 10;            
 277   1              if ( tic01 == 0 ) {
 278   2                      SystemClock++;
 279   2                      if(OsdTimerClock)
 280   2                              OsdTimerClock--;
 281   2      #if defined(SUPPORT_I2CCMD_TEST_SLAVE)
                              if(ext_i2c_timer)
                                      ext_i2c_timer--;
              #endif
 285   2      
 286   2      #ifdef SW_I2C_SLAVE
                              //recover i2c_index if it has same value until 10ms.
                              if(sw_i2c_index==sw_i2c_index_old)
                                      sw_i2c_index=0;
                              sw_i2c_index_old=sw_i2c_index;
              #endif
 292   2              }
 293   1              tic_pc++;               //WORD size
 294   1              tic_task++;             //WORD size
 295   1      #ifdef SUPPORT_HDMI_SiIRX
                  wTickCnt++;
                  //decrement all active timers in array until they reach 00
                  for (i = 0; i < CONF__TIMER_COUNT; i++ )
                  {
                      if (TimerArray[ i ] > 0)
                      {
                          TimerArray[ i ]--;
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 6   

                      }
                  }
              #endif
 306   1      
 307   1              SFR_ET0=1;
 308   1      }
 309          //*****************************************************************************
 310          //*      Ext Int 1 Interrupt  (Low / Falling)                   : <<DE End>>    P2.1
 311          //*****************************************************************************
 312          BYTE ext1_intr_flag;
 313          void ext1_int(void) interrupt 2 using 1
 314          {
 315   1      #ifdef DEBUG_ISR
                      MCU_INT_STATUS |= 0x0004;
              #endif
 318   1              SFR_EX1 = 0;
 319   1      }
 320          
 321          //****************************************************************************
 322          //*      Timer 1 Interrupt : for Touch sensing & key sensing                                           
 323          //****************************************************************************
 324          WORD    CpuTouchX, CpuTouchY, CpuZ1, CpuZ2;
 325          bit             CpuTouchPressed=0;
 326          WORD    CpuAUX0 = 0;
 327          WORD    CpuAUX1 = 0;
 328          WORD    CpuAUX2 = 0;
 329          WORD    CpuAUX3 = 0;
 330          BYTE    CpuAUX0_Changed = 0;
 331          BYTE    CpuAUX1_Changed = 0;
 332          BYTE    CpuAUX2_Changed = 0;
 333          BYTE    CpuAUX3_Changed = 0;
 334          BYTE    CpuTouchStep=0, CpuTouchChanged=0;
 335          
 336          WORD    CpuTouchSkipCount=0;
 337          #define ReadTscData(TscData) TscData = ReadTW88(REG0B2); TscData <<= 4; TscData += ReadTW88(REG0B3) 
 338          #ifdef MODEL_TW8835_EXTI2C
              BYTE timer1_intr_count=0;
              //---------------------
              //every 200msec.
              void timer1_int(void) interrupt 3 using 1
              {
                      timer1_intr_count++;
              }
              //FYI:and, see TscPseudoISR()
              #else //..MODEL_TW8835_EXTI2C
 348          //---------------------
 349          /**
 350          * timer1 interrupt service routine
 351          * 
 352          * for Touch
 353          * every 500usec. use 82uS @ 27MHz
 354          * @todo too big
 355          */
 356          void timer1_int(void) interrupt 3 using 1
 357          {
 358   1      #if defined(SUPPORT_TOUCH) || defined(SUPPORT_KEYPAD)
 359   1              //; DECLARE_LOCAL_page
 360   1              WORD diff;
 361   1              static WORD TX,TY;
 362   1              WORD TscData;
 363   1              static WORD     temp;
 364   1      
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 7   

 365   1      SFR_ET1=0;
 366   1      
 367   1              if(CpuTouchSkipCount) {
 368   2                      CpuTouchSkipCount--;
 369   2                      SFR_ET1=1;
 370   2                      return;
 371   2              }
 372   1      
 373   1              ReadTW88Page(page);
 374   1              WriteTW88Page(PAGE0_TOUCH);
 375   1      
 376   1              if ( CpuTouchStep == 0 ) {                                      // start Measure Z2
 377   2                      //TSC MODE : 2 : Z2 measure
 378   2                      ReadTscData(TscData);
 379   2                      if ( TscData > 0x800 ) {                                        
 380   3                              WriteTW88(REG0B0, 0x01 );               // adc  mode Z1
 381   3                              CpuTouchStep++;                                 // 1
 382   3                              temp = 0;                                               // clear
 383   3                              CpuZ2 = TscData;                                                        
 384   3                      }
 385   2                      else {
 386   3                              CpuTouchStep = 5;
 387   3                      }
 388   2              }
 389   1              else if ( CpuTouchStep == 1 ) {                  // check Z1
 390   2                      //TSC MODE : 1 : Z1 measure
 391   2                      ReadTscData(TscData);
 392   2                      if ( TscData > temp )   diff = TscData - temp;
 393   2                      else                                    diff = temp - TscData;
 394   2      
 395   2                      if ( diff < 10 ) {                                      // find stable value
 396   3                              if ( TscData < 100 ) {                  // no touch
 397   4                                      CpuTouchPressed = 0;
 398   4                                      CpuTouchStep = 5;
 399   4                                      CpuTouchChanged++;
 400   4                              }
 401   3                              else {
 402   4                                      WriteTW88(REG0B0, 0 );          // adc start with mode XPOS
 403   4                                      CpuTouchStep++;                         // restart Touch measurement
 404   4                                      temp = 0;                                       // clear
 405   4                              }
 406   3                      }
 407   2                      else {
 408   3                              temp = TscData;                                 // redo measure
 409   3                              //WriteTW88(REG0B0, 0x01 );             // adc  mode Z1
 410   3                      }
 411   2              }
 412   1              else if ( CpuTouchStep == 2 ) {                  // check XPOS
 413   2                      //TSC MODE : 0 : X position measure
 414   2                      ReadTscData(TscData);
 415   2      
 416   2                      if ( TscData > temp )   diff = TscData - temp;
 417   2                      else                                    diff = temp - TscData;
 418   2                              
 419   2                      if ( diff < 10 ) {                                      // find stable value
 420   3                              WriteTW88(REG0B0, 0x03 );               // adc start with mode YPOS
 421   3                              CpuTouchStep++;
 422   3                              temp = 0;                                               // clear
 423   3                              TX = TscData;
 424   3                      }
 425   2                      else {
 426   3                              temp = TscData;                                 // redo measure
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 8   

 427   3                              //WriteTW88(REG0B0, 0 );                        // adc start with mode XPOS
 428   3                      }
 429   2              }
 430   1              else if ( CpuTouchStep == 3 ) {                 // check YPOS
 431   2                      //TSC MODE : 3 : Y position measure
 432   2                      ReadTscData(TscData);
 433   2      
 434   2                      if ( TscData > temp )   diff = TscData - temp;
 435   2                      else                                    diff = temp - TscData;
 436   2      
 437   2                      if ( diff < 10 ) {                                      // find stable value
 438   3                              WriteTW88(REG0B0, 0x01 );               // adc start with mode Z1
 439   3                              temp = 0;                                               // clear
 440   3                              CpuTouchStep++;
 441   3                              TY = TscData;
 442   3                      }
 443   2                      else {
 444   3                              temp = TscData;                                 // redo measure
 445   3                              //--WriteTW88(REG0B0, 0x03 );   // adc start with mode YPOS
 446   3                      }
 447   2              }
 448   1              else if ( CpuTouchStep == 4 ) {                 // check z1
 449   2                      //TSC MODE : 1 : Z1 measure
 450   2                      ReadTscData(TscData);
 451   2      
 452   2                      if ( TscData > temp )   diff = TscData - temp;
 453   2                      else                                diff = temp - TscData;
 454   2      
 455   2                      if ( diff < 10 ) {                                      // find stable value
 456   3                              if ( TscData < 100 ) {                  // no touch, reset touch interrupt
 457   4                                      CpuTouchPressed = 0;
 458   4                                      CpuTouchChanged++;
 459   4                              }
 460   3                              else {
 461   4                                      //===================
 462   4                                      //
 463   4                                      //===================
 464   4                                      CpuTouchX = TX;
 465   4                                      CpuTouchY = TY;
 466   4                                      CpuZ1 = TscData;
 467   4                                      CpuTouchChanged++;
 468   4                                      CpuTouchPressed = 1;
 469   4                              }
 470   3                              CpuTouchStep++;
 471   3                      }
 472   2                      else {
 473   3                              temp = TscData;                                 // redo measure
 474   3                              //WriteTW88(REG0B0, 0x01 );             // adc start with mode Z
 475   3                      }
 476   2              }
 477   1              else if ( CpuTouchStep == 5 ) {                 // Start AUX input check
 478   2                      WriteTW88(REG0B0, 0x07 );                       // write Start, erase Ready, mode AUX0
 479   2                      CpuTouchStep++;
 480   2                      temp = 0;
 481   2              }
 482   1              else if ( CpuTouchStep == 6 ) { 
 483   2                      //TSC MODE : 7 : AUX3 measure
 484   2                      ReadTscData(TscData);
 485   2      
 486   2                      if ( TscData > temp )   diff = TscData - temp;
 487   2                      else                                    diff = temp - TscData;
 488   2                              
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 9   

 489   2                      if ( diff < 10 ) {                                      // find stable value
 490   3                              CpuAUX3 = TscData;
 491   3                              CpuAUX3_Changed++;
 492   3                              WriteTW88(REG0B0, 2 );                  // write Start, erase Ready, mode Z2
 493   3                              temp = 0;
 494   3                              CpuTouchStep = 0;                                               
 495   3                      }
 496   2                      else {
 497   3                              temp = TscData;                                 // redo measure
 498   3                              //--WriteTW88(REG0B0, 7 );              // write Start, erase Ready, mode AUX[3]
 499   3                      }
 500   2      
 501   2              }
 502   1              WriteTW88Page(page );
 503   1      SFR_ET1=1;
 504   1      //PORT_DEBUG = 1;
 505   1      
 506   1      #endif //..SUPPORT_TOUCH
 507   1      }
 508          #endif //..MODEL_TW8835_EXTI2C
 509          #undef ReadTscData
 510          
 511          
 512          //*****************************************************************************
 513          //      UART 0 Interrupt                                                   
 514          //*****************************************************************************
 515          /**
 516          * UART0 interrupt service routine
 517          * 
 518          */
 519          void uart0_int(void) interrupt 4 using 1
 520          {
 521   1      #ifdef DP80390
                      BYTE    count;
              #endif
 524   1      
 525   1              SFR_ES=0;
 526   1      #ifdef DEBUG_ISR
                      MCU_INT_STATUS |= 0x0010;
              #endif
 529   1      
 530   1              if( SFR_RI ) {                                  //--- Receive interrupt ----
 531   2                      SFR_RI = 0;
 532   2      #ifdef DP80390
                              if ( SFR_UART0FIFO & 0x80 ) {           // use fifo?
                                      count = SFR_UART0FIFO & 0x1F;
                                      if ( count & 0x10) {
                                              SFR_UART0FIFO = 0x90;           // overflowed, buffer clear
                                      }
                                      else {
                                              while (count) {
                                                      RS_buf[RS_in++] = SFR_SBUF;
                                                      if( RS_in>=RS_BUF_MAX ) RS_in = 0;
                                                      count--;
                                              };
                                      }
                              }
                              else 
              #endif
 548   2                      {
 549   3                              RS_buf[RS_in++] = SFR_SBUF;
 550   3                              if( RS_in>=RS_BUF_MAX ) RS_in = 0;
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 10  

 551   3                      }
 552   2              }
 553   1      
 554   1              if( SFR_TI ) {                                  //--- Transmit interrupt ----
 555   2                      SFR_TI = 0;
 556   2                      RS_Xbusy=0;
 557   2              }
 558   1              SFR_ES=1;
 559   1      }
 560          
 561          //****************************************************************************
 562          //*      Timer 2 Interrupt                                                              : <<Remo Timer>>
 563          //****************************************************************************
 564          #ifdef REMO_RC5
 565          #ifdef DEBUG_REMO
              BYTE RemoCapture0[14+1];
              BYTE RemoCapture1[14+1];
              BYTE RemoCapture2[14+1];
              #endif
 570          /**
 571          * timer2 interrupt service routine
 572          *
 573          * for remocon 
 574          */
 575          void timer2_int(void) interrupt 5 using 1                       // using register block 3
 576          {
 577   1              BYTE    i;
 578   1              bit sample;
 579   1      
 580   1      SFR_ET2=0;
 581   1      #ifdef DEBUG_ISR
                      MCU_INT_STATUS |= 0x0020;
              #endif
 584   1              SFR_T2IF &= 0xfc;                               // Clear Interrupt Flag
 585   1      
 586   1              RemoTic++;
 587   1              sample = REMO_IN;
 588   1      
 589   1      #ifdef DEBUG_REMO
                      if(RemoTic==5) {
                              if(RemoCaptureDisable==0)
                                      RemoCapture0[0] = 0x0F; //valid 0..4    
                              if(RemoCaptureDisable==1)
                                      RemoCapture1[0] = 0x0F; 
                              if(RemoCaptureDisable==2)
                                      RemoCapture2[0] = 0x0F; 
                      }
              
                      i = (RemoTic & 0x07);
                      if(RemoTic <= 8*14) {
                              if(sample) {
                                      if(RemoCaptureDisable==0)
                                              RemoCapture0[RemoTic >> 3] |= (1 << i); 
                                      if(RemoCaptureDisable==1)
                                              RemoCapture1[RemoTic >> 3] |= (1 << i); 
                                      if(RemoCaptureDisable==2)
                                              RemoCapture2[RemoTic >> 3] |= (1 << i); 
                              }
                      }
              #endif
 611   1      
 612   1      
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 11  

 613   1              i = RemoTic & 0x07;
 614   1              if     ( i==1 ) RemoPhase1 = sample; //REMO_IN;
 615   1              else if( i==5 ) RemoPhase2 = sample; //REMO_IN;
 616   1      
 617   1              //----- Received 1 Bit -----
 618   1              else if( i==0 ) {       //every 8 RemoTic
 619   2                      if( RemoPhase1==RemoPhase2 ) {  // error
 620   3                              ClearRemoTimer();                       
 621   3                              EnableRemoInt();
 622   3      
 623   3                              SFR_ET2=1;      //SFR_EA = 1;
 624   3      
 625   3                              return;
 626   3                      }
 627   2                      if( RemoTic<=(8*8) ) {                          // SystemCode. Start1+Start2 + Tottle + 5 BIT ADDRESS
 628   3                              RemoSystemCode <<=1;
 629   3                              if( RemoPhase1==1 && RemoPhase2==0 )
 630   3                                      RemoSystemCode |=1;
 631   3                      }
 632   2                      else {                                                          // DataCode.  6 BIT COMMAND
 633   3                              RemoDataCode <<=1;
 634   3                              if( RemoPhase1==1 && RemoPhase2==0 )
 635   3                                      RemoDataCode |=1;
 636   3                      }
 637   2                      //----- Received 1 Packet -----
 638   2                      if( RemoTic >= (8*14) ) {
 639   3                              RemoDataReady++;        // RemoDataReady = 1;                           // new key
 640   3      #ifdef DEBUG_REMO
                                      if(RemoCaptureDisable==0) {  RemoSystemCode0 = RemoSystemCode; RemoDataCode0 = RemoDataCode; }
                                      if(RemoCaptureDisable==1) {  RemoSystemCode1 = RemoSystemCode; RemoDataCode1 = RemoDataCode; }
                                      if(RemoCaptureDisable==2) {  RemoSystemCode2 = RemoSystemCode; RemoDataCode2 = RemoDataCode; }
                                      RemoCaptureDisable++;
              #endif
 646   3                              RemoReceivedTime = SystemClock;
 647   3      
 648   3                              //if(RemoSystemCode&0x40 == RemoSystemCode&0x02)
 649   3      
 650   3                              ClearRemoTimer();                               
 651   3                      }
 652   2              }
 653   1      SFR_ET2=1;
 654   1      }
 655          #endif //..REMO_RC5
 656          #ifdef REMO_NEC
              void timer2_int(void) interrupt 5 using 1                       // using register block 3
              {
              EA = 0;
              
                      T2IF &= 0xfc;                           // Clear Interrupt Flag
              
                      RemoTic++;
              
                      if( RemoDataReady ) {
                              
                              EA = 1;
              
                              return;
                      }
              
                      switch( RemoStep ) {
              
                      case 0:
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 12  

                              //wait 9ms.
                              if( REMO_IN==0 ) {
                                      RemoLcnt++;
                                      if( RemoLcnt==0xff ) //wait 42.38...samples
                                              goto RemoError;
                              }
                              else {
                                      RemoHcnt = 0;
                                      RemoStep++;
                              }
                              break;
              
                      case 1:
                              //wait 4.5ms for normal........ wait 24.106 samples
                              //wait 2.25ms for repeat code.. wait 12.053 samples
                              if( REMO_IN==1 ) {
                                      RemoHcnt++;
                                      if( RemoHcnt==0xff )  //
                                              goto RemoError;
                              }
                              else {
                                      if( RemoLcnt>=15*3 && RemoLcnt<=17*3 ) {        //target 16*3 = 48
                                              
                                              if( RemoHcnt>=3*3 && RemoHcnt<=5*3 ) {  //target 4*3 = 12
                                                      RemoStep = 3;
                                                      #ifdef DEBUG_REMO_NEC
                                                      if(DebugRemoStep==0) {
                                                              DebugRemoStep = RemoStep;
                                                              DebugRemoLcnt = RemoLcnt;
                                                              DebugRemoHcnt = RemoHcnt;
                                                      }
                                                      #endif
                                                      RemoDataReady = 2;                                       //auto repeat..
                                                      break;
                                              }
                                              else if( RemoHcnt>=7*3 && RemoHcnt<=9*3 ) {     //target 8*3 = 24
                                                      RemoStep++;                                                             //move to RemoStep 2.
                                                      #ifdef DEBUG_REMO_NEC
                                                      if(DebugRemoStep==0) {
                                                              DebugRemoStep = RemoStep;
                                                              DebugRemoLcnt = RemoLcnt;
                                                              DebugRemoHcnt = RemoHcnt;
                                                      }
                                                      #endif
                                                      RemoPhase = 0;
                                                      RemoLcnt = 0;
                                                      RemoNum  = 0;
                                                      RemoBit  = 0;
              
                                                      break;
                                              }
                                      }
                                      else goto RemoError;
                              }
                              break;
              
                      case 2:
                              if( RemoPhase==0 ) {
                                      if( REMO_IN==0 )                                        // Phase=0  Input=0
                                              RemoLcnt++;
                                      else {                                                          // Phase=0  Input=1
                                              RemoPhase = 1;
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 13  

                                              RemoHcnt = 0;
                                      }
                              }
                              else {                                                          
                                      if( REMO_IN==1 )                                        // Phase=1  Input=1
                                              RemoHcnt++;
                                      else {                                                          // Phase=1  Input=0
                                              RemoPhase = 0;
                                              if( RemoLcnt>=1 && RemoLcnt<=5 ) {
                                                      if( RemoHcnt<=2*3 )                     // bit 0
                                                              RemoData[RemoNum] <<= 1;
                                                      else if( RemoHcnt<=4*3 ) {              // bit 1
                                                              RemoData[RemoNum] <<= 1;
                                                              RemoData[RemoNum]++;
                                                      }
                                                      else goto RemoError;
              
                                                      if( ++RemoBit>=8 ) {
                                                              RemoBit = 0;
                                                              if( ++RemoNum>=4 ) {
                                                                      RemoDataReady = 1;
                                                                      RemoStep++;
                                                              }
                                                      }
                                                      RemoLcnt = 0;
              
                                              }
                                              else goto RemoError;
                                      }
                              }
                              break;
              
                      case 3:
                              break;
                      
                      }
                      EA = 1;
                      return;
              
              RemoError:
                      ClearRemoTimer();               //TimerFor208us();
                      EnableRemoInt();                //EnableRemoconInt();
              
                      EA = 1;
              }
              #endif  //..REMO_NEC
 783          
 784          //*****************************************************************************
 785          //      UART 1 Interrupt                                                   
 786          //*****************************************************************************
 787          #ifdef SUPPORT_UART1
              /**
              * UART1 interrupt service routine
              * 
              */
              void uart1_int(void) interrupt 6 using 1
              {
              #ifdef MODEL_TW8836
                      BYTE    count;
              #endif
              
                      SFR_EA = 0;
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 14  

              #ifdef DEBUG_ISR
                      MCU_INT_STATUS |= 0x0040;
              #endif
              
                      if( SFR_RI1 ) {                                 //--- Receive interrupt ----
                              SFR_RI1 = 0;
              #ifdef DP80390
                              if ( SFR_UART1FIFO & 0x80 ) {                   // use fifo?
                                      count = SFR_UART1FIFO & 0x1F;
                                      if ( count & 0x10) {
                                              SFR_UART1FIFO = 0x90;           // overflowed, buffer clear
                                      }
                                      else {
                                              while (count) {
                                                      RS1_buf[RS1_in++] = SFR_SBUF1;
                                                      if( RS1_in>=RS_BUF_MAX ) RS1_in = 0;
                                                      count--;
                                              };
                                      }
                              }
                              else
              #endif
                              {
                                      RS1_buf[RS1_in++] = SFR_SBUF1;
                                      if( RS1_in >= RS_BUF_MAX ) RS1_in = 0;
                              }
                      }
              
                      if( SFR_TI1 ) {                                 //--- Transmit interrupt ----
                              SFR_TI1 = 0;
                              RS1_Xbusy=0;
                      }
                      SFR_EA = 1;
              }
              #endif
 834          
 835          //*****************************************************************************
 836          //*      Ext Int 2 Interrupt  (Low)                                     : <<DMA Done>>          P2.2    EXIF0
 837          //*****************************************************************************
 838          #ifdef MODEL_TW8835_EXTI2C
              void ext2_int(void) interrupt 7 using 1
              {
                      SFR_EX1=0;
              #ifdef DEBUG_ISR
                      MCU_INT_STATUS |= 0x0080;
              #endif
              
                      SFR_EX1=1;
              }
              #else //..MODEL_TW8835_EXTI2C
 849          void ext2_int(void) interrupt 7 using 1
 850          {
 851   1              DECLARE_LOCAL_page
 852   1              BYTE val;
 853   1      
 854   1              SFR_EX1=0;
 855   1      #ifdef DEBUG_ISR
                      MCU_INT_STATUS |= 0x0080;
              #endif
 858   1      
 859   1              ReadTW88Page(page);
 860   1              WriteTW88Page(PAGE0_GENERAL);
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 15  

 861   1              val = ReadTW88(REG002);
 862   1              WriteTW88(REG002, 0x80);        // Clear Int            
 863   1      
 864   1              WriteTW88Page(page);
 865   1              SFR_EX1=1;
 866   1      }
 867          #endif //..MODEL_TW8835_EXTI2C
 868          
 869          //*****************************************************************************
 870          //*      Ext Int 3 Interrupt (Low)                                              : <<Touch Ready>>       P2.3    EXIF1
 871          //*****************************************************************************
 872          void ext3_int(void) interrupt 8 using 1
 873          {
 874   1      #ifdef DEBUG_ISR
                      MCU_INT_STATUS |= 0x0100;
              #endif
 877   1      }
 878          //*****************************************************************************
 879          //*      Ext Int 4 Interrupt (Low)                                              : XRAM 0x7FF access by I2C, reserved            EXIF2
 880          //*****************************************************************************
 881          void ext4_int(void) interrupt 9 using 1
 882          {
 883   1              SFR_EINT4 = 0;
 884   1      #ifdef DEBUG_ISR
                      MCU_INT_STATUS |= 0x0200;
              #endif
 887   1              IntCount++;
 888   1      
 889   1      #ifdef MODEL_TW8836
              #ifndef MODEL_TW8835_EXTI2C
                      INT_STATUS3 = ReadTW88(REG002) & 0x10;
                      WriteTW88(REG002, INT_STATUS3);         //clear 
              #endif
              #endif
 895   1              //SFR_EINT4 = 1;
 896   1      }
 897          //*****************************************************************************
 898          //*      Ext Int 5 Interrupt (Falling)                                  : reserved
 899          //*****************************************************************************
 900          void ext5_int(void) interrupt 10 using 1
 901          {
 902   1      #ifdef DEBUG_ISR
                      MCU_INT_STATUS |= 0x0400;
              #endif
 905   1      }
 906          //*****************************************************************************
 907          //*      Ext Int 6 Interrupt (Falling)                                  : <<Pen Int>> P2.4
 908          //*****************************************************************************
 909          void ext6_int(void) interrupt 11 using 1
 910          {
 911   1      #ifdef DEBUG_ISR
                      MCU_INT_STATUS |= 0x0800;
              #endif
 914   1      }
 915          //*****************************************************************************
 916          //*      Watchdog Interrupt                                                             : <<Watchdog>>
 917          //*****************************************************************************
 918          #pragma SAVE
 919          #pragma OPTIMIZE(8,SPEED)
 920          /**
 921          * watchdog interrupt service routine
 922          * 
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 16  

 923          * only for debug.
 924          */
 925          void watchdog_int(void) interrupt 12 using 0
 926          {
 927   1              SFR_EWDI = 0;
 928   1      
 929   1      #ifdef DEBUG_ISR
                      MCU_INT_STATUS |= 0x1000;
              #endif
 932   1      
 933   1      #ifdef DEBUG_WATCHDOG
                      F_watch = 1;
              #endif
 936   1      
 937   1              SFR_TA = 0xaa;
 938   1              SFR_TA = 0x55;
 939   1              SFR_WDCON = 0x03;       // - - - - WDIF WTRF EWT RWT
 940   1      
 941   1              SFR_EWDI = 1;
 942   1      }
 943          #pragma RESTORE
 944          
 945          
 946          //*****************************************************************************
 947          //*      Ext Int 7 Interrupt (Programable)                              : <<INT 7>>             P1.0
 948          //*****************************************************************************
 949          void ext7_int(void) interrupt 13 using 1
 950          {
 951   1      SFR_EA = 0;
 952   1              EXINT_STATUS |= 1;
 953   1              IntCount++;
 954   1      
 955   1              SFR_E2IF  = 0x01;               // Clear Flag, if Edge triggered
 956   1      SFR_EA = 1;
 957   1      }
 958          //*****************************************************************************
 959          //*      Ext Int 8 Interrupt (Programable)                              : <<INT 8>>             P1.1
 960          //*****************************************************************************
 961          void ext8_int(void) interrupt 14 using 1
 962          {
 963   1      SFR_EA = 0;
 964   1              EXINT_STATUS |= 2;
 965   1      
 966   1              SFR_E2IF  = 0x02;               // Clear Flag, if Edge triggered
 967   1      SFR_EA = 1;
 968   1      }
 969          //*****************************************************************************
 970          //*      Ext Int 9 Interrupt (Programable)                              : <<INT 9>>             P1.2  Remocon
 971          //*****************************************************************************
 972          void ext9_int(void) interrupt 15 using 1
 973          {
 974   1      SFR_EA = 0;
 975   1              EXINT_STATUS |= 4;
 976   1              IntCount++;
 977   1      
 978   1              DisableRemoInt();
 979   1              SFR_E2IF  = 0x04;               // Clear Flag, if Edge triggered
 980   1      
 981   1              InitRemoTimer();
 982   1      SFR_EA = 1;
 983   1      }
 984          //*****************************************************************************
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 17  

 985          //*      Ext Int 10 Interrupt (Programable)                             : <<INT 10>>    P1.3
 986          //*****************************************************************************
 987          #ifdef MODEL_TW8835_EXTI2C
              BYTE eint10_intr_count=0;
              void ext10_int(void) interrupt 16 using 1
              {
              //PORT_DEBUG = 0;
              SFR_EA = 0;
                      EXINT_STATUS |= 8;
                      IntCount++;
              
                      SFR_E2IF  = 0x08;               // Clear Flag, if Edge triggered
                      eint10_intr_count++;
              
              SFR_EA = 1;
              //PORT_DEBUG = 1;
              }
              #else //..MODEL_TW8835_EXTI2C
1003          /**
1004          * ext10 interrupt service routine
1005          * 
1006          * used for I2C and Internal MCU chip arbitration
1007          */
1008          void ext10_int(void) interrupt 16 using 1
1009          {
1010   1      //PORT_DEBUG = 0;
1011   1      SFR_EA = 0;
1012   1              EXINT_STATUS |= 8;
1013   1              IntCount++;
1014   1      
1015   1              SFR_E2IF  = 0x08;               // Clear Flag, if Edge triggered
1016   1      
1017   1      #ifdef MODEL_TW8835_SLAVE
                      SFR_EX0=0;              //off ext0_int
                      SFR_ET1=0;              //off timer1 that for tsc
                      while(PORT_I2CCMD_GPIO_SLAVE==0);       //wait
                      SFR_EX0=1;              //restore
              #ifdef SUPPORT_TOUCH
                      SFR_ET1=1;              //restore
              #endif
              #endif
1026   1      
1027   1      SFR_EA = 1;
1028   1      //PORT_DEBUG = 1;
1029   1      }
1030          #endif //..MODEL_TW8835_EXTI2C
1031          
1032          //*****************************************************************************
1033          //*      Ext Int 11 Interrupt (Programable)                             : <<INT 11>             P1.4
1034          //*****************************************************************************
1035          void ext11_int(void) interrupt 17 using 1
1036          {
1037   1      SFR_EA = 0;
1038   1              EXINT_STATUS |= 0x10;
1039   1      
1040   1              SFR_E2IF  = 0x10;               // Clear Flag, if Edge triggered
1041   1      SFR_EA = 1;
1042   1      }
1043          //*****************************************************************************
1044          //*      Ext Int 12 Interrupt (Programable)                             : <<INT 12>>    P1.5
1045          // PowerDown....
1046          //*****************************************************************************
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 18  

1047          void ext12_int(void) interrupt 18 using 1
1048          {
1049   1      SFR_EA = 0;
1050   1              EXINT_STATUS |= 0x20;
1051   1      
1052   1              SFR_E2IF  = 0x20;               // Clear Flag, if Edge triggered
1053   1      SFR_EA = 1;
1054   1      }
1055          //*****************************************************************************
1056          //*      Ext Int 13 Interrupt (Programable)                             : <<INT 13>>    P1.6
1057          //*****************************************************************************
1058          #ifdef SW_I2C_SLAVE
              void ext13_int(void) interrupt 19 using 1
              {
                      BYTE sw_i2c_sub_index;
              SFR_EA = 0;
              
                      dbg_sw_i2c_scl_count++;
                      if(sw_i2c_index==0) {
                              I2C_SCL_CLEAR_INTR_FLAG;
                              EA = 1;
                              //PORT_DEBUG = 1;
              
                              return;
                      }
              
              
                      if(sw_i2c_devid==SW_I2C_SLAVE_ID_W) {   //MasterWrite
              
                              sw_i2c_data <<= 1;      //make a room
                              sw_i2c_data |= SW_I2C_SDA;
              
                              sw_i2c_sub_index = sw_i2c_index & 0x0F;
              
                              if(sw_i2c_sub_index == 0x09) { //0x09,0x19,0x29,..
                                      //on falling
                                      //I2C_SCL = 0;  //Hold SCL LOW.if slave need more time
                                      I2C_SDA = 0;    //send ACK
                                      sw_i2c_index++;
                              }
                              else if(sw_i2c_sub_index == 0x0A) { //0x0A,0x1A,0x2A,.. 
                                      //on falling
                                      // ACK clock
                                      I2C_SDA = 1;    //recover ACK
                                      I2C_SCL_WAIT_RISING;
                                      
                                      if(sw_i2c_index==0x0A)
                                              sw_i2c_index=0x11;
                                      else if(sw_i2c_index==0x1A)
                                              sw_i2c_index=0x21;
                                      else
                                              sw_i2c_index=0x31;
              
                              }
                              else if(sw_i2c_index==0x18) {
                                      //on rising
                                      //index
                                      sw_i2c_regidx = sw_i2c_data;    //save register index
                                      dbg_sw_i2c_regidx[dbg_sw_i2c_sda_count-1] = sw_i2c_data;
                                      I2C_SCL_WAIT_FALLING;   //change to Falling
                                      sw_i2c_index++;
                              }
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 19  

                              else if(sw_i2c_sub_index==0x08) {       //0x28,
                                      //on rising
                                      //write data
                                      dbg_sw_i2c_data[dbg_sw_i2c_sda_count-1] = sw_i2c_data;
                                      WriteTW88(sw_i2c_regidx++,sw_i2c_data);
                                      I2C_SCL_WAIT_FALLING;   //change to Falling
                                      sw_i2c_index++;
                              }
                              else {
                                      sw_i2c_index++;
                              }
                      }
                      else if(sw_i2c_devid==SW_I2C_SLAVE_ID_R) {      //MasterRead
              
                              if(sw_i2c_index==9) {
                                      //on falling
                                      //I2C_SCL = 0;  //Hold SCL LOW
                                      I2C_SDA = 0;    //send ACK
                                      sw_i2c_index = 0x21;
                                      //prepare data to send
                                      sw_i2c_data=ReadTW88(sw_i2c_regidx++);
                                      dbg_sw_i2c_data[dbg_sw_i2c_sda_count-1] = sw_i2c_data;
                                      //I2C_SCL = 1;  //Release SCL. SCL=1;
                              }
                              else if(sw_i2c_index ==0x29) {
                                      //on falling
                                      I2C_SCL_WAIT_RISING;    //wait rising
              
                                      I2C_SDA = 1; //listen for ACK
                                      sw_i2c_index++;
                              }       
                              else if(sw_i2c_index==0x2A) { //0x2A,..
                                      //on rising
                                      //check ACK/NAK
                                      if(I2C_SDA==0) {
                                              //ACK. Continue
                                              sw_i2c_data=ReadTW88(sw_i2c_regidx++);
                                              I2C_SCL_WAIT_FALLING;
                                              dbg_sw_i2c_data[dbg_sw_i2c_sda_count-1] = 0xAC; //NAK.Continue
                                              sw_i2c_index= 0x21;
                                      }
                                      else {
                                              //NAK. Last
                                              //now wait STOP
                                              //DisableInterrupt(EINT_SW_I2C_SCL_NUM);
                                              dbg_sw_i2c_data[dbg_sw_i2c_sda_count-1] = 0xAE; //ACK. End
                                              sw_i2c_index = 0;
                                              sw_i2c_devid = 0;
                                              I2C_SCL_CLEAR_INTR_FLAG;
                                              I2C_SCL_DISABLE_INTR;
                                              EA = 1;
                                              //PORT_DEBUG = 1;
              
                                              if(dbg_sw_i2c_sda_count<6)
                                                      dbg_sw_i2c_sda_count++;
              
                                              return;
                                      }
                              }
                              else { //(sw_i2c_index>=0x21 && sw_i2c_index<=0x28)
                                      //on falling
                                      I2C_SDA = sw_i2c_data & 0x80 ? 1:0;
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 20  

                                      sw_i2c_data <<=1;
                                      sw_i2c_index++;
                              }
                      }
                      else {
                              //assume sw_i2c_index from 1 to 8.
                              //on Rising
              
                              sw_i2c_data <<= 1;                      //make a room
                              sw_i2c_data |= SW_I2C_SDA;
              
                              if(sw_i2c_index == 8) {
                                      //check devid & R/W
              
                                      dbg_sw_i2c_devid[dbg_sw_i2c_sda_count-1] = sw_i2c_data;
              
                                      if(sw_i2c_data==SW_I2C_SLAVE_ID_W || sw_i2c_data==SW_I2C_SLAVE_ID_R) {
                                              sw_i2c_devid = sw_i2c_data;             //save devid
                                              I2C_SCL_WAIT_FALLING;                   //change to Falling
                                      }
                                      else {  
                                              //NOT MINE. turnoff EINT13 
                                              sw_i2c_index = 0;
                                              sw_i2c_devid = 0;
                                              I2C_SCL_CLEAR_INTR_FLAG;
                                              I2C_SCL_DISABLE_INTR;
                                              EA = 1;
                                              //PORT_DEBUG = 1;
              
                                              //dbg allow only one last command
                                              dbg_sw_i2c_index[dbg_sw_i2c_sda_count-1] = sw_i2c_index;
                                              if(dbg_sw_i2c_sda_count==0)
                                                      dbg_sw_i2c_sda_count++;
              
                                              return;
                                      }
                              }
                              sw_i2c_index++;
                      }
                      dbg_sw_i2c_index[dbg_sw_i2c_sda_count-1] = sw_i2c_index;
              
                      SFR_E2IF  = 0x40;               // Clear Flag, if Edge triggered
              SFR_EA = 1;
              }
              #else //..SW_I2C_SLAVE
1216          void ext13_int(void) interrupt 19 using 1
1217          {
1218   1      SFR_EA = 0;
1219   1              EXINT_STATUS |= 0x40;
1220   1      
1221   1              SFR_E2IF  = 0x40;               // Clear Flag, if Edge triggered
1222   1      SFR_EA = 1;
1223   1      }
1224          #endif //..SW_I2C_SLAVE
1225          
1226          
1227          
1228          /*
1229          =====================
1230          SINGLE
1231          WRITE  S DEVID A REGIDX A DATA A P
1232          READ   S DEVID A REGIDX A S DEVID+1 DATA A P
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 21  

1233           
1234          MULTI
1235          WRITE  S DEVID A REGIDX A DATA A DATA A .. DATA A E(STOP)
1236          READ   S DEVID A REGIDX A S DEVID+1 DATA A DATA A .. DATA A E(STOP)
1237          
1238          Normal Write
1239          =================
1240          Master-+   +----+----..-----+----+----+----..----+----+----+----+-...--+   +---
1241          SDA    |   |    |    ..     |    |    |    ..    |    |    |    |      |   |    
1242                 +---+----+----..-----+    +----+----..----+    +----+----+-...--+---+    
1243          SCL   ---+  +-+  +-+    +-+  +-+  +-+  +-+    +-+  +-+  +-+  +-+          +---+
1244                   |  |7|  |6|    |0|  |A|  | |  | |    | |  |A|  | |  | |          |   |
1245                   +--+ +--+ +-..-+ +--+ +--+ +--+ +..--+ +--+ +--+ +--+ +--......--+   +---
1246          index  0    0    0          0 0    0  1    1      1 1    1  2    2                                                              
1247                     0    1        2          8 9    A  1    2      8 9    A  1    2                                                              
1248          Slave -+   +----+----..-----+   +----+----+----..----+    +---------+...----+  +---- 
1249          SDA    |   |    |    ..     |   |    |    |    ..    |    |         |       |  |   
1250                 +---+----+----..-----+---+----+----+----..----+----+---------+...    +--+
1251                 |                                                                   |
1252                 |                                                                   |
1253                 +START                                                              +STOP
1254                             |<-   DevID  ->|     ACK  |<-   RegIdx  ->| ACK |  DATA  ... |ACK|    
1255          
1256          Normal Read
1257          ===========
1258                                                  +--Prepare Restart condition
1259                                      |   +==RESTART
1260          Master..----+W-R--+-W---W   +----+----..----+W-R--+----+----..----+----W NAK+----+--..
1261          SDA   ..    |     | |   |   |    |    ..    |     |    |    ..    |    |A/N |    |     
1262                ..----+     +-+   +---+----+----..----+     +----+----..----+----W-ACK+----+--..   
1263          SCL      +-+  +-+    +-----+  +-+  +-+    +-+  +-+  +-+  +-+    +-+  +-+  +-+  +-+    
1264                   | |  |A|    |     |  |7|  |6|    |0|  |A|  |7|  |6|    |1|  |0|  |A|  | |    
1265                .--+ +--+ +----+     +--R +--R +-..-R R--+ R--+ +--+ +..--+ +--+ +--+ +--+ +--.. 
1266          index    1 1    1    2( 2)0   0    0      0 0    2    2           2    2  2 2    2                                                                      
1267                       8 9    A    1( 2)0   1        2      8 9    1    2           8    9  A 1    2              
1268                                                                   DevID+1               READ DATA           A/N 
1269          Slave                                  ..----+    +----+----+...   +---+W--R+  +---- 
1270          SDA                                    ..    | A  | D7 | D6 |      | D0|    |  |   
1271                                                 ..----W----W----W----+...   +W--+    +--+
1272          
1273          Multi Read
1274          ==========
1275          Master..----+W-R--+----+----..----+----+    +----+----..----+----W-NAK--+   W-----
1276          SDA   ..    |     |    |    ..    |    |    |    |    ..    |    |      |   |   
1277                ..----+     +----+----..----+----W-ACK+----+----..----+----+      W---+   
1278          SCL      +-+  +-+  +-+  +-+    +-+  +-+  +-+  +-+  +-+    +-+  +-+  +--+  +----    
1279                   |0|  |A|  |7|  |6|    |1|  |0|  |A|  |7|  |6|    |1|  |0|  |A |  | STOP    
1280                ..-+ +--+ +--+ +--+ +..--+ +--+ +--+ +--+ +--+ +..--+ +--+ +--+  +--+  
1281          index    0 0    2    2           2    2  2 2    2           2    2  2 0                                                                         
1282                       8 9        1    2           8    9  A 1    2           8    9  A 0         
1283                               READ DATA           A/N 
1284          Slave ..----+    +----+----+...   +---+W--R+----+----+...   +---+W--R- 
1285          SDA   ..    | A  | D7 | D6 |      | D0|    | D7 | D6 |      | D0|        
1286                ..----W----W----W----+...   +W--+    W----W----+... --+W--+     
1287          
1288          
1289          */
1290          
1291          //*****************************************************************************
1292          //*      Ext Int 14 Interrupt (Programable)                                     : <<INT 14>>            P1.7
1293          //*****************************************************************************
1294          #ifdef SW_I2C_SLAVE
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 22  

              void ext14_int(void) interrupt 20 using 1
              {
              SFR_EA = 0;
              //PORT_DEBUG = 0;
              
                      if(SW_I2C_SCL) {
                              //filter for invalid slow START
                              //when read, master intensionally up the SCL and then down SDL.
                              //SW will increase one sw_i2c_index, so I checked a 0x22, not 0x21.
                              if(sw_i2c_index!=0 && sw_i2c_index!=0x22) {
              
                                      dbg_sw_i2c_devid[dbg_sw_i2c_sda_count] = dbg_sw_i2c_devid[dbg_sw_i2c_sda_count-1];
                                      dbg_sw_i2c_regidx[dbg_sw_i2c_sda_count]= dbg_sw_i2c_regidx[dbg_sw_i2c_sda_count-1];
                                      dbg_sw_i2c_data[dbg_sw_i2c_sda_count]  = dbg_sw_i2c_data[dbg_sw_i2c_sda_count-1];
              
                                      dbg_sw_i2c_index[dbg_sw_i2c_sda_count-1] = sw_i2c_index;
                                      dbg_sw_i2c_data[dbg_sw_i2c_sda_count-1] = 0xBA;  //BAD
                                      dbg_sw_i2c_sda_count++;
              
                                      E2IF  = 0x80;           // Clear Flag, if Edge triggered
              //                      PORT_DEBUG = 1;
                                      EA = 1;
                                      return;
                              }
              
                              if(dbg_sw_i2c_sda_count<6) {
                                      dbg_sw_i2c_index[dbg_sw_i2c_sda_count] = 0;
                                      dbg_sw_i2c_sda_count++;
                              }
              
                              //START.
                              //      reset internal logic.
                              //on falling
              
                              sw_i2c_index=1;
                              sw_i2c_devid = 0;
                              I2C_SCL_WAIT_RISING;
                              if(E2IF & 0x40)
                                      E2IF  = 0x40;           //Clear Flag, if Edge triggered
                              E2IE |=  0x40;                  //enable EINT13
                      }                       
                      E2IF  = 0x80;           // Clear Flag, if Edge triggered
              //PORT_DEBUG = 1;
              SFR_EA = 1;
              }
              #else //..SW_I2C_SLAVE
1341          void ext14_int(void) interrupt 20 using 1
1342          {
1343   1      SFR_EA = 0;
1344   1              EXINT_STATUS |= 0x80;
1345   1              SFR_E2IF  = 0x80;               // Clear Flag, if Edge triggered
1346   1      SFR_EA = 1;
1347   1      }
1348          #endif //..SW_I2C_SLAVE
1349          
1350          //*****************************************************************************
1351          
1352          
1353          //=============================================================================
1354          //              Serial RX Check                                                                                                    
1355          //=============================================================================
1356          /**
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 23  

1357          * check Serial RX
1358          */
1359          BYTE RS_ready(void)
1360          {
1361   1              if( RS_in == RS_out ) return 0;
1362   1              else return 1;
1363   1      }
1364          #ifdef SUPPORT_UART1
              BYTE RS1_ready(void)
              {
                      if( RS1_in == RS1_out ) return 0;
                      else return 1;
              }
              #endif
1371          
1372          //=============================================================================
1373          //              Serial RX                                                                                                                  
1374          //=============================================================================
1375          /**
1376          * get Rx data
1377          */
1378          BYTE RS_rx(void)
1379          {
1380   1              BYTE    ret;
1381   1      
1382   1              SFR_ES = 0;
1383   1              ret = RS_buf[RS_out];
1384   1              RS_out++;
1385   1              if(RS_out >= RS_BUF_MAX) 
1386   1                      RS_out = 0;
1387   1              SFR_ES = 1;
1388   1      
1389   1              return ret;
1390   1      }
1391          /**
1392          * unget Rx data
1393          */
1394          void RS_ungetch(BYTE ch)
1395          {
1396   1              RS_buf[RS_in++] = ch;
1397   1              if( RS_in>=RS_BUF_MAX ) RS_in = 0;
1398   1      }
1399          #ifdef SUPPORT_UART1
              BYTE RS1_rx(void)
              {
                      BYTE    ret;
              
                      SFR_ES1 = 0;
                      ret = RS1_buf[RS1_out];
                      RS1_out++;
                      if(RS1_out >= RS_BUF_MAX) 
                              RS1_out = 0;
                      SFR_ES1 = 1;
              
                      return ret;
              }
              void RS1_ungetch(BYTE ch)
              {
                      RS1_buf[RS1_in++] = ch;
                      if( RS1_in >=RS_BUF_MAX ) RS1_in = 0;
              }
              #endif
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 24  

1419          
1420          //=============================================================================
1421          //              Serial TX                                                                                                                  
1422          //=============================================================================
1423          /**
1424          * send Tx
1425          */
1426          void RS_tx(BYTE tx_buf)
1427          {
1428   1              while(RS_Xbusy);
1429   1      
1430   1              SFR_ES = 0;                     // To protect interrupt between SBUF and RS_Xbusy when it's slow
1431   1              SFR_SBUF = tx_buf;
1432   1              RS_Xbusy=1;
1433   1              SFR_ES = 1;
1434   1      }
1435          #ifdef SUPPORT_UART1
              void RS1_tx(BYTE tx_buf)
              {
                      while(RS1_Xbusy);
              
                      SFR_ES1 = 0;                    // To protect interrupt between SBUF and RS_Xbusy when it's slow
                      SFR_SBUF1 = tx_buf;
                      RS1_Xbusy=1;
                      SFR_ES1 = 1;
              }
              #endif
1446          //=============================================================================
1447          //                                                                                                                 
1448          //=============================================================================
1449          /**
1450          * 1ms delay
1451          *
1452          * tic_pc will be increased every 1 timer0 interrupt that based 1ms.
1453          * tic_pc: 0~0xffff and will not increased after 0xffff.
1454          * @param cnt_1ms have to less then 65536. max 65sec delay
1455          */
1456          void delay1ms(WORD cnt_1ms)
1457          {
1458   1              tic_pc = 0;
1459   1      
1460   1              while(tic_pc < cnt_1ms);
1461   1      }
1462          
1463          /**
1464          * 1sec delay
1465          */
1466          void delay1s(WORD cnt_1s, WORD line)
1467          {
1468   1              WORD i;
1469   1              Printf("\nWait%ds @%d",cnt_1s,line);
1470   1              for(i=0; i < cnt_1s; i++) {
1471   2                      delay1ms(1000);
1472   2              }
1473   1      }
1474          
1475          //=============================================================================
1476          //                            Watchdog                                                   
1477          //=============================================================================
1478          #pragma SAVE
1479          #pragma OPTIMIZE(8,SIZE)
1480          
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 25  

1481          #if defined(SUPPORT_WATCHDOG) || defined(DEBUG_WATCHDOG)
              /**
              * restart watchdog
              */
              void RestartWatchdog(void)
              {
              #ifdef DEBUG_WATCHDOG
                      SFR_EWDI = 0;           // Disable WDT Interrupt
              #endif
                      SFR_TA = 0xaa;
                      SFR_TA = 0x55;
                      SFR_WDCON = 0x03;       // - - - - WDIF WTRF EWT RWT.  Reset Watchdog
                      
              #ifdef DEBUG_WATCHDOG
                      F_watch = 0;
                      SFR_EWDI = 1;           // Enable WDT Interrupt (disable for test)
              #endif
              }
              
              /**
              * enable Watchdog
              */
              void EnableWatchdog(BYTE mode)
              {
                      Printf("\nEnableWatchdog(%bd)",mode);
              #ifdef DEBUG_WATCHDOG
                      SFR_EWDI = 0;           // Disable WDT Interrupt
              #endif
                      //ePuts("\nEnableWatchlog");
              
                      SFR_CKCON &= 0x3F;
                      switch(mode) {
                      case 0:         SFR_CKCON |= 0xc0;      break;  // WDT clock = 2^26      0x04000000     9.95sec@32KHz
                      case 1:         SFR_CKCON |= 0x80;      break;  // WDT clock = 2^23: 0x00800000 1.25sec@32KHz test only
                      case 2:         SFR_CKCON |= 0x40;      break;  // WDT clock = 2^20: 0x00100000 0.16sec@32KHz test only
                      case 3:         SFR_CKCON |= 0x00;      break;  // WDT clock = 2^17: 0x00020000 0.03sec@32KHz test only
                      default:        SFR_CKCON |= 0xc0;      break;
                      }
              
                      SFR_TA = 0xaa;
                      SFR_TA = 0x55;
                      SFR_WDCON = 0x03;       // - - - - WDIF WTRF EWT RWT.  Reset Watchdog
              
                      SFR_EIP |= 0x20;        //??BK120502
              #ifdef DEBUG_WATCHDOG
                      SFR_EWDI = 1;           // Enable WDT Interrupt (disable for test)
              #endif
              }
              #pragma RESTORE
              
              /*
              Note: See the OK and NG code. If you use OPTIMIZE(9,), the compiler made a NG code.
              OK:
                      MOV     SFR_TA,#0AAH
                      MOV     SFR_TA,#055H
                      MOV     SFR_WDCON,#00H
                      SETB    SFR_EWDI
              
              NG:
                      MOV     SFR_TA,#0AAH
                      MOV     SFR_TA,#055H
                      CLR     A
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 26  

                      MOV     SFR_WDCON,A
                      CLR     SFR_EWDI
              */
              #pragma SAVE
              #pragma OPTIMIZE(2,SIZE)
              /**
              * disable watchdog
              */
              void DisableWatchdog(void)
              {
                      SFR_TA = 0xaa;
                      SFR_TA = 0x55;
                      SFR_WDCON = 0x00;       // - - - - WDIF WTRF EWT RWT
              
                      SFR_EWDI = 0;           // Disable WDT Interrupt
                      ePuts("\nDisableWatchlog");
              }
              #pragma RESTORE
              #endif //..defined(SUPPORT_WATCHDOG) || defined(DEBUG_WATCHDOG)
1562          
1563          /**
1564          * enable external interrupt
1565          */
1566          void EnableInterrupt(BYTE intrn)
1567          {
1568   1              SFR_E2IE |= (1 << intrn);       
1569   1      }
1570          /**
1571          * disable externel interrupt
1572          */
1573          void DisableInterrupt(BYTE intrn)
1574          {
1575   1              SFR_E2IE &= ~(1 << intrn);      
1576   1      }
1577          
1578          //=============================================================================
1579          //                      Remocon
1580          //=============================================================================
1581          //BKFYI: It is in the ISR of INT9
1582          #ifdef REMO_RC5
1583          
1584          /**
1585          * init remocon timer
1586          */
1587          void InitRemoTimer(void)
1588          {
1589   1      #ifdef DEBUG_REMO
                      BYTE i;
              #endif
1592   1      
1593   1              //WORD temp;
1594   1              ClearRemoTimer();                       //T2CON = 0x00;                         // 
1595   1               
1596   1              SFR_ET2  = 0;                           // Disable Timer2 Interrupt
1597   1              SFR_T2IF = 0x00;                        // Clear Flag
1598   1      
1599   1                                                                      // Reload Value
1600   1              SFR_CRCH = SFR_TH2 = 0xff;      // 0xFF2E = 0x10000-0xD2 = 0x10000-210. 
1601   1              SFR_CRCL = SFR_TL2 = 0x2e;      // it means 210 usec interval. 
1602   1      
1603   1              SFR_CRCL = SFR_TL2 = 0x2D;              
1604   1                                                                      //RC5 uses 14 bytes.
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 27  

1605   1                                                                      //RC5 spec uses a 24892us for 14 byte.
1606   1                                                                      //TW8835 use a 8 sampling per one bit 
1607   1                                                                      //If remocon use a 24892us for 14 Bytes, we have to assign 222us interval.
1608   1                                                                      // 
1609   1                                                                      //When I measure a data1 signal from the first falling edge to the last up edge, it was 22800us.
1610   1                                                                      //and it starts from first falling edge.
1611   1                                                                      // 22800us = (14*8-4) * interval. 
1612   1                                                                      // the best interval value is 211us.
1613   1      
1614   1      
1615   1              SFR_T2CON = 0x12;                       // 0001 0010 
1616   1                                                                      // |||| |||+-- T2I0 \ Timer2 Input Selection 
1617   1                                                                      // |||| ||+--- T2I1 / 00=No,  01=Timer,  10=Counter, 11=Gate
1618   1                                                                      // |||| |+---- T2CM:  Compare mode
1619   1                                                                      // |||| +----- T2R0 \ Timer2 Reload Mode 
1620   1                                                                      // |||+------- T2R1     / 00=No,  01=No,     10=Auto,    11=pin T2EX
1621   1                                                                      // ||+-------- ---
1622   1                                                                      // |+--------- I3FR: Timer2 Compare0 Interrupt Edge...
1623   1                                                                      // +---------- T2PS: Timer2 Prescaler
1624   1      
1625   1              //start from...
1626   1              RemoTic = 4;
1627   1              RemoPhase1 = 1;
1628   1      
1629   1      #ifdef DEBUG_REMO
                      if(RemoCaptureDisable==0) {
                              for(i=0; i <= 14; i++) {
                                      RemoCapture0[i]=0x00;
                                      RemoCapture1[i]=0x00;
                                      RemoCapture2[i]=0x00;
                              }
                      }
              #endif
1638   1              //BKFYI.
1639   1              //the next timer2 ISR will be RemoTic 5, and ISR will capture the sample RemoPhase2.
1640   1              //The RemoPhase2 have to be 0 in our system(Active Low). 
1641   1      
1642   1              RemoSystemCode = 0;
1643   1              RemoDataCode = 0;
1644   1      
1645   1              SFR_ET2  = 1;                                   // Enable Timer 2 Interrupt
1646   1      }
1647          
1648          #elif defined REMO_NEC
              
              void InitRemoTimer(void)
              {
                      WORD temp;
              
                      ClearRemoTimer();                       //T2CON = 0x00; 
                       
                      ET2  = 0;                                       // Disable Timer2 Interrupt
                      T2IF = 0x00;                            // Clear Flag
              
                                                                              //need 186.667us 
                      temp = 0x10000 - 187;           //or 186        0x10000- BA. 186.667uS  
              
                      CRCH = TH2 = temp>>8;
                      CRCL = TL2 = (BYTE)(temp & 0xff);
              
                      T2CON = 0x12;                           // 0001 0010 
                                                                              // |||| |||+-- T2I0 \ Timer2 Input Selection 
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 28  

                                                                              // |||| ||+--- T2I1 / 00=No,  01=Timer,  10=Counter, 11=Gate
                                                                              // |||| |+---- T2CM:  Compare mode
                                                                              // |||| +----- T2R0 \ Timer2 Reload Mode 
                                                                              // |||+------- T2R1     / 00=No,  01=No,     10=Auto,    11=pin T2EX
                                                                              // ||+-------- ---
                                                                              // |+--------- I3FR: Timer2 Compare0 Interrupt Edge...
                                                                              // +---------- T2PS: Timer2 Prescaler
              
              
                      RemoTic = 0;            //tm01 = 0;
                      RemoStep  = 0;
                      RemoPhase = 0;
                      RemoHcnt  = 0;
                      RemoLcnt  = 0;
              
                      ET2  = 1;                                       // Enable Timer 2 Interrupt
              }
              
              #endif
1686          
1687          //=============================================================================
1688          //                            Initialize CPU                                                   
1689          //=============================================================================
1690          /**
1691          * initialize CPU(8051 MCU)
1692          */
1693          void InitCPU(void)
1694          {
1695   1      //#ifdef SUPPORT_HDMI_SiIRX
1696   1      #ifdef MODEL_TW8836FPGA
                      BYTE i;
              #endif
1699   1      //#endif
1700   1              TWBASE = 0x00;                                  // Base address of TW88xx
1701   1      #ifndef SUPPORT_8BIT_CHIP_ACCESS
1702   1              SFR_E2 = 1;                                             //Chip Access Mode Control. E2[0]=1b:16bit mode
1703   1      #endif
1704   1      
1705   1              //---------- Initialize Timer Divider ---------
1706   1      
1707   1      #ifdef MODEL_TW8835_EXTI2C
                      WriteHostPage(PAGE4_CLOCK);
              
                      WriteHost(REG4E2, 0x69);                // Timer0 Divider : system tic 0. 
                      WriteHost(REG4E3, 0x78);                // 27M/27000 = 1msec
              
              
                      //WriteHost(REG4E4, 0x0A);              // Timer1 Divider : for Touch
                      //WriteHost(REG4E5, 0x8C);              // 27MHz/2700 = 100usec
              
                      WriteHost(REG4E4, 0x15);                // Timer1 Divider : for Touch
                      WriteHost(REG4E5, 0x18);                // 27MHz/5400 = 200usec
              
                      //WriteHost(REG4E4, 0x69);              // Timer1 Divider : for Touch
                      //WriteHost(REG4E5, 0x78);              // 27MHz/27000 = 1msec
              
              
                      WriteHost(REG4E6, 0);                   // Timer2 Divider : remo timer
                      WriteHost(REG4E7, 0x1b);                // 27M/27 = 1usec
              
                      WriteHost(REG4E8, 0);                   // Timer3 Divider : baudrate for UART0
                      WriteHost(REG4E9, 0x0c);                // (22.1184M/16) / 12 = 115200bps on SM0=1      
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 29  

              
                      WriteHost(REG4EA, 0);                   // Timer4 Divider : baudrate for UART1
                      WriteHost(REG4EB, 0x18);                // (22.1184M/16) / 24 = 57600bps on SM1=1       
              #else
1733   1              WriteTW88Page(PAGE4_CLOCK);
1734   1      
1735   1              WriteTW88(REG4E2, 0x69);                // Timer0 Divider : system tic 0. 
1736   1              WriteTW88(REG4E3, 0x78);                // 27M/27000 = 1msec
1737   1      
1738   1              WriteTW88(REG4E4, 0x01);                // Timer1 Divider : for Touch
1739   1              WriteTW88(REG4E5, 0x0e);                // 27M/270 = 10usec     
1740   1      
1741   1              WriteTW88(REG4E6, 0);                   // Timer2 Divider : remo timer
1742   1              WriteTW88(REG4E7, 0x1b);                // 27M/27 = 1usec
1743   1      
1744   1              WriteTW88(REG4E8, 0);                   // Timer3 Divider : baudrate for UART0
1745   1              WriteTW88(REG4E9, 0x0c);                // (22.1184M/16) / 12 = 115200bps on SM0=1      
1746   1      
1747   1              WriteTW88(REG4EA, 0);                   // Timer4 Divider : baudrate for UART1
1748   1              WriteTW88(REG4EB, 0x18);                // (22.1184M/16) / 24 = 57600bps on SM1=1       
1749   1      #endif
1750   1              //---------- Initialize interrupt -------------
1751   1      
1752   1              SFR_CKCON = 0x00;               // Clock control register                       
1753   1                                                              // 0000 0000
1754   1                                                              // |||| |||+-- MD0 \.
1755   1                                                              // |||| ||+--- MD1      > MD[2:0] Stretch RD/WR timing
1756   1                                                              // |||| |+---- MD2 /
1757   1                                                              // |||| +----- T0M:  Timer0 Pre-Divider 0=div by 12,  1=div by 4
1758   1                                                              // |||+------- T1M:  Timer1 Pre-Divider 0=div by 12,  1=div by 4
1759   1                                                              // ||+-------- ---
1760   1                                                              // |+--------- WD0 \ Watchdong Timeout Period
1761   1                                                              // +---------- WD1 / 00=2^17,  01=2^20,  10=2^23,  11=2^26
1762   1      
1763   1          SFR_TMOD = 0x66;            // 0110 0110
1764   1                                                              // |||| ||||   << Timer 0 >>
1765   1                                                              // |||| |||+-- M0 \  00= 8bit timer,counter /32  01= 16bit timer,counter
1766   1                                                              // |||| ||+--- M1 /  10= 8bit auto reload        11= 8bit timer,counter
1767   1                                                              // |||| |+---- CT:   0=Timer Mode,    1=Counter Mode
1768   1                                                              // |||| +----- GATE: 0=GATE not used, 1=GATE used
1769   1                                                              // ||||        << Timer 1 >>
1770   1                                                              // |||+------- M0 \  00= 8bit timer,counter /32  01= 16bit timer,counter
1771   1                                                              // ||+-------- M1 /  10= 8bit auto reload        11= 8bit timer,counter
1772   1                                                              // |+--------- CT:   0=Timer Mode,    1=Counter Mode
1773   1                                                              // +---------- GATE: 0=GATE not used, 1=GATE used
1774   1      
1775   1          SFR_TCON = 0x55;            // 0101 0101
1776   1                                                              // |||| |||+-- IT0:  INT0 Trigger 0=level, 1=edge
1777   1                                                              // |||| ||+--- IE0:  INT0 Interrupt Flag
1778   1                                                              // |||| |+---- IT1:  INT1 Trigger 0=level, 1=edge
1779   1                                                              // |||| +----- IE1:  INT1 Interrupt Flag
1780   1                                                              // |||+------- TR0:  Timer0 Run
1781   1                                                              // ||+-------- TF0:  Timer0 Flag
1782   1                                                              // |+--------- TR1:  Timer1 Run
1783   1                                                              // +---------- TF0:  Timer1 Flag
1784   1                                                              
1785   1              SFR_TH0 = 0xff;                 // 1 msec
1786   1              SFR_TL0 = 0xff;                 //
1787   1      
1788   1                                                              // for TOUCH SAR sensing timer
1789   1      #ifdef MODEL_TW8835_EXTI2C
                      SFR_TH1 = 156;                  // TH1 = 156. 10ms      = 100*100usec. if REG4E4:REG4E5=0x0A8C
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 30  

                                                                      //            20ms  = 100*200usec. if REG4E4:REG4E5=0x1518
                                                                      //            100ms     = 100*1msec.   if REG4E4:REG4E5=0x6978
              #else
1794   1              SFR_TH1 = 206;                  // 
1795   1                                                              // TH1 = 156. 1ms
1796   1                                                              // TH1 = 206. 0.5ms = 50*10usec
1797   1      #endif
1798   1      
1799   1              SFR_PCON = 0xc0;                // 1100 0000
1800   1                                                              // |||| |||+-- PMM:  Power Management Mode 0=Disable,  1=Enable
1801   1                                                              // |||| ||+--- STOP: Stop Mode             0=Disable,  1=Enable
1802   1                                                              // |||| |+---- SWB:  Switch Back from STOP 0=Disable,  1=Enable
1803   1                                                              // |||| +----- ---
1804   1                                                              // |||+------- PWE:      (Program write Enable)
1805   1                                                              // ||+-------- ---
1806   1                                                              // |+--------- SMOD1:UART1 Double baudrate bit
1807   1                                                              // +---------- SMOD0:UART0 Double baudrate bit
1808   1      
1809   1              SFR_SCON = 0x50;                // 0101 0000
1810   1                                                              // |||| |||+-- RI:   Receive Interrupt Flag
1811   1                                                              // |||| ||+--- TI:   Transmit Interrupt Flag
1812   1                                                              // |||| |+---- RB08: 9th RX data
1813   1                                                              // |||| +----- TB08: 9th TX data
1814   1                                                              // |||+------- REN:      Enable Serial Reception
1815   1                                                              // ||+-------- SMO2: Enable Multiprocessor communication
1816   1                                                              // |+--------- SM01 \   Baudrate Mode
1817   1                                                              // +---------- SM00 / 00=f/12,  01=8bit var,  10=9bit,f/32,f/64,  11=9bit var
1818   1      
1819   1              SFR_SCON1 = 0x50;               // 0101 0000
1820   1                                                              // |||| |||+-- RI:   Receive Interrupt Flag
1821   1                                                              // |||| ||+--- TI:   Transmit Interrupt Flag
1822   1                                                              // |||| |+---- RB08: 9th RX data
1823   1                                                              // |||| +----- TB08: 9th TX data
1824   1                                                              // |||+------- REN:      Enable Serial Reception
1825   1                                                              // ||+-------- SMO2: Enable Multiprocessor communication
1826   1                                                              // |+--------- SM11 \   Baudrate Mode
1827   1                                                              // +---------- SM10 / 00=f/12,  01=8bit var,  10=9bit,f/32,f/64,  11=9bit var
1828   1      
1829   1              SFR_IP   = 0x02;                // 0000 0000 interrupt priority                                 
1830   1                                                              // -  PS1 PT2 PS PT1 PX1 PT0 PX0                                 
1831   1      
1832   1              //---------- Enable Individual Interrupt ----------
1833   1                                                              // IE(0xA8) = EA ES1 ET2 ES  ET1 EX1 ET0 EX0
1834   1              SFR_EX0  = 1;                   // INT0         : Chip Interrupt
1835   1              SFR_ET0  = 1;                   // Timer0       : System Tic
1836   1              SFR_EX1 =  0;                   // INT1         : DE end
1837   1              SFR_ET1  = 0;                   // Timer1       : touch
1838   1              SFR_ET2  = 0;                   // Timer2       : Remote
1839   1              SFR_ES   = 1;                   // UART0        : Debug port
1840   1      #ifdef DP80390
                      SFR_UART0FIFO = 0x80;   //          : UART0 FIFO
              #endif
1843   1      #ifdef SUPPORT_UART1
                      SFR_ES1  = 1;                   // UART1        : External MCU
              #ifdef DP80390
                      SFR_UART1FIFO = 0x80;   //          : UART1 FIFO
              #endif
              #else
1849   1              SFR_ES1  = 0;                   // UART1        : External MCU
1850   1      #endif
1851   1              SFR_EA   = 1;                   // Global Interrupt
1852   1      
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 31  

1853   1              //---------- Extended Interrupt -------------------
1854   1                                                              // 0xe8 xx xx EWDI EINT6 EINT5 EINT4 EINT3 EINT2
1855   1              SFR_EINT2 = 0;                  // INT2         : SPI-DMA done
1856   1              SFR_EINT3 = 0;                  // INT3         : Touch Ready
1857   1      #ifdef MODEL_TW8836
                      SFR_EINT4 = 1;                  // INT4         : SW 7FF 
              #else
1860   1              SFR_EINT4 = 0;                  // INT4         : reserved 
1861   1      #endif
1862   1              SFR_EINT5 = 0;                  // INT5         : reserved
1863   1              SFR_EINT6 = 0;                  // INT6         : Pen
1864   1              //---------- Extended Interrupt 7~14 Config. ---------------
1865   1                                                              // EINT14 EINT13 EINT12 EINT11 EINT10 EINT9 EINT8 EINT7
1866   1                                                              //
1867   1                                                              // EINT9 : Remocon. SW will enable 9 later.
1868   1                                                              // EINT10: MODEL_TW8835_EXTI2C. VideoISR. 
1869   1                                                              //                 MODEL_TW8835_SLAVE. Master I2C active. SW will enable INT10 later.
1870   1                                                              // EINT14:
1871   1              SFR_E2IF  = 0x00;               // (0xFA)       0000 0000 : Interrupt Flag         
1872   1              SFR_E2IE  = 0x00;               // (0xFB)       0000 0000 : Interrupt Enable.
1873   1              SFR_E2IP  = 0x00;               // (0xFC)       0000 0000 : Interrupt Priority
1874   1              SFR_E2IM  = 0xff;               // (0xFD)       0000 0000 : Interrupt Mode(0=Edge,  1=Level)
1875   1              SFR_E2IT  = 0x00;               // (0xFE)       0000 0000 : Level/Edge Polarity  (0=Low/Falling, 1=High/Rising)   0xFE
1876   1              //BKTODO120606 Why Level ?. 0x08
1877   1      #if defined(MODEL_TW8835_EXTI2C) 
                      SFR_E2IE  = 0x08;
              #endif
1880   1      
1881   1              Puts("\n\n\n\n\nInitCPU ");
1882   1      #ifdef SUPPORT_8BIT_CHIP_ACCESS
                      Puts("8Bit Access");
              #else
1885   1              Puts("16Bit Access");
1886   1      #endif
1887   1      
1888   1              //------- Remote Controller (INT9, Timer2) --------
1889   1      
1890   1              SFR_T2CON = 0x00;               //ClearRemoTimer. RemoINTR(EINT9) will be activateed in RemoTimer               
1891   1      
1892   1              //cache on :: sfr 9b = 1;
1893   1              Puts(" CACHE");
1894   1              SFR_CACHE_EN = 0x01;    //cache ON. No Power Down
1895   1      
1896   1      #ifdef SUPPORT_HDMI_SiIRX
                  //initializer timer counters in array
                  for (i = 0; i < CONF__TIMER_COUNT; i++)
                  {
                      TimerArray[ i ] = 0;
                  }
              #endif
1903   1      
1904   1      #ifdef MODEL_TW8836FPGA
                      //TW8836 don't have PORT_NOINIT_MODE. FW starts as NOINIT
                      if(1)
              #else
1908   1              if(PORT_NOINIT_MODE == 1)
1909   1      #endif
1910   1              {
1911   2                      //BK120608 you have to recover it.
1912   2                      SFR_EX0=0;
1913   2                      Printf("\nSKIP EX0 E2IE[2] ET1");
1914   2              }
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 32  

1915   1      }
1916          
1917          #ifndef MODEL_TW8836RTL
1918          /**
1919          * init Interrupt Service Routine
1920          *
1921          * only for TEST
1922          */
1923          void InitISR(BYTE flag)
1924          {
1925   1              BYTE i;
1926   1              i = flag;       //warning
1927   1      
1928   1              WriteTW88Page(0);
1929   1              WriteTW88(REG002, ReadTW88(REG002));            //clear 
1930   1              WriteTW88(REG004, ReadTW88(REG004) & 0x07);     //clear
1931   1              SFR_EX0  = 1;                           // INT0         : Chip Interrupt
1932   1      
1933   1              SFR_IE1 = 0;                            // Clear Pending Interrupt
1934   1              //SFR_EX1  = 1;                         // INT1         : DE end
1935   1      
1936   1              //SFR_EINT2 = 1;                        // INT2         : SPI-DMA done
1937   1                                                      
1938   1              if(SFR_E2IF & 0x04)
1939   1                      SFR_E2IF  = 0x04;               //Clear Flag, if Edge triggered
1940   1              EnableRemoInt();                        //timer2 Remo. INT9
1941   1      
1942   1              InitTouch();                            //timer1 touch
1943   1      }
1944          #endif
1945          
1946          #ifdef SUPPORT_HDMI_SiIRX
              //------------------------------------------------------------------------------
              // Function: TIMER_Set
              // Description: Set value of specified timer.
              //              Value must be greater than 00 to enable the timer.
              //              Timer begins decrementing on the next timer tick inetrrupt.
              //------------------------------------------------------------------------------
              void TIMER_Set(uint8_t index, uint16_t value)
              {
                  if (index < CONF__TIMER_COUNT)
                  {
                      TimerArray[index] = value;
                  }
              }
              //------------------------------------------------------------------------------
              // Function: TIMER_Expired
              // Description: Check if specified timer is expired.
              //              If timer value is 00, then timer is stopped (expired).
              //------------------------------------------------------------------------------
              BYTE TIMER_Expired(uint8_t index)
              {
                  if (index < CONF__TIMER_COUNT)
                  {
                      return (TimerArray[index] == 0);
                  }
              
                  return ( 0 );
              }
              //------------------------------------------------------------------------------
              // Function: TIMER_Wait
              // Description: Blocking wait for timer to expire - use with caution.
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 33  

              //------------------------------------------------------------------------------
              void TIMER_Wait(uint8_t index, uint16_t value)
              {
                  TIMER_Set(index, value);
              
                  while (!TIMER_Expired(index))
                      ;  //empty wait loop
                      //TODO:Add watchdog.
              }
              #endif
1987          
1988          //=============================================================================
1989          //              Time
1990          //=============================================================================
1991          #ifdef SUPPORT_FOSD_MENU
              DATA    BYTE    SleepTimer;
              DATA    WORD    SleepTime;
              #define _24H_SECS                       86400L                  // 24*60*60
              
              WORD DiffTime_ms( WORD stime, WORD etime )
              {
                      if( etime < stime ) {                   // resetted
                              return etime + (6000 - stime);
                      }
                      else {
                              return etime - stime;
                      }
              }
              
              WORD GetTime_ms(void)
              {
                      WORD tms;
              
                      tms = tic01;
                      tms += ( SystemClock * 1000 );
                      return tms;     // in ms
              }
              BYTE GetTime_H(void)
              {
                      return ( SystemClock / 60 / 60 ) % 24 ;
              }
              BYTE GetTime_M(void)
              {
                      return ( SystemClock / 60  ) % 60 ;
              }
              BYTE GetSleepTimer(void)
              {
                      WORD val;
              
                      val = SleepTimer;
                      if( val )       {       // already set, display rest of time
                              val = ( SleepTime >> 8 ) * 60 + ( SleepTime & 0xff );
                              val -= ( GetTime_H() * 60 + GetTime_M() );
                      }
                      return (BYTE)val;
              }
              void SetSleepTimer(BYTE stime)
              {
                      SleepTimer = stime;
                      if( SleepTimer==0 )
                              SleepTime = 0xffff;
                      else {
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 34  

                              SleepTime = GetTime_H() + ( GetTime_M() + SleepTimer ) / 60;
                              SleepTime = ( SleepTime << 8 ) | ( ( GetTime_M() + SleepTimer ) % 60 );
                      }
              
                      #ifdef DEBUG_TIME
                      dPrintf("\nSetSleepTimer(SleepTime:0x%bx)", SleepTime);
                      #endif
              }
              #endif
2048          
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 35  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION Com007B (BEGIN)
0000         L?0124:
0000         L?0125:
0000 E500        R     MOV     A,regTW88+01H
0002 24B2              ADD     A,#0B2H
0004 F582              MOV     DPL,A
0006 E4                CLR     A
0007 3500        R     ADDC    A,regTW88
0009 F583              MOV     DPH,A
000B E0                MOVX    A,@DPTR
000C 7A00              MOV     R2,#00H
000E C4                SWAP    A
000F F8                MOV     R0,A
0010 540F              ANL     A,#0FH
0012 C8                XCH     A,R0
0013 68                XRL     A,R0
0014 FB                MOV     R3,A
0015 EA                MOV     A,R2
0016 C4                SWAP    A
0017 54F0              ANL     A,#0F0H
0019 48                ORL     A,R0
001A FA                MOV     R2,A
001B E500        R     MOV     A,regTW88+01H
001D 24B3              ADD     A,#0B3H
001F         L?0126:
001F F582              MOV     DPL,A
0021 E4                CLR     A
0022 3500        R     ADDC    A,regTW88
0024 F583              MOV     DPH,A
0026 22                RET     
0027         L?0127:
0027         L?0128:
0027 900000      R     MOV     DPTR,#IntCount
002A E0                MOVX    A,@DPTR
002B FC                MOV     R4,A
002C A3                INC     DPTR
002D E0                MOVX    A,@DPTR
002E FD                MOV     R5,A
002F A3                INC     DPTR
0030 E0                MOVX    A,@DPTR
0031 FE                MOV     R6,A
0032 A3                INC     DPTR
0033 E0                MOVX    A,@DPTR
0034 2401              ADD     A,#01H
0036 FF                MOV     R7,A
0037 E4                CLR     A
0038 3E                ADDC    A,R6
0039 FE                MOV     R6,A
003A E4                CLR     A
003B 3D                ADDC    A,R5
003C FD                MOV     R5,A
003D E4                CLR     A
003E 3C                ADDC    A,R4
003F FC                MOV     R4,A
0040 900000      R     MOV     DPTR,#IntCount
0043 020000      E     LJMP    ?C?LSTXDATA
0046         L?0129:
0046         L?0130:
0046 C3                CLR     C
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 36  

0047 900000      R     MOV     DPTR,#temp+01H
004A E0                MOVX    A,@DPTR
004B 9B                SUBB    A,R3
004C FE                MOV     R6,A
004D 900000      R     MOV     DPTR,#temp
0050 E0                MOVX    A,@DPTR
0051 9A                SUBB    A,R2
0052 900000      R     MOV     DPTR,#diff
0055 F0                MOVX    @DPTR,A
0056 A3                INC     DPTR
0057 CE                XCH     A,R6
0058 F0                MOVX    @DPTR,A
0059 22                RET     
005A         L?0131:
005A         L?0132:
005A E0                MOVX    A,@DPTR
005B 2B                ADD     A,R3
005C FB                MOV     R3,A
005D E4                CLR     A
005E 3A                ADDC    A,R2
005F FA                MOV     R2,A
0060 900000      R     MOV     DPTR,#temp
0063 E0                MOVX    A,@DPTR
0064 FE                MOV     R6,A
0065 A3                INC     DPTR
0066 E0                MOVX    A,@DPTR
0067 FF                MOV     R7,A
0068 C3                CLR     C
0069 9B                SUBB    A,R3
006A EE                MOV     A,R6
006B 9A                SUBB    A,R2
006C 22                RET     
006D         L?0133:
006D         L?0134:
006D C3                CLR     C
006E EB                MOV     A,R3
006F 9F                SUBB    A,R7
0070 FF                MOV     R7,A
0071 EA                MOV     A,R2
0072 9E                SUBB    A,R6
0073 900000      R     MOV     DPTR,#diff
0076 F0                MOVX    @DPTR,A
0077 A3                INC     DPTR
0078 EF                MOV     A,R7
0079 F0                MOVX    @DPTR,A
007A 22                RET     
007B         L?0135:
007B         L?0136:
007B C3                CLR     C
007C 900000      R     MOV     DPTR,#diff+01H
007F E0                MOVX    A,@DPTR
0080 940A              SUBB    A,#0AH
0082 900000      R     MOV     DPTR,#diff
0085 E0                MOVX    A,@DPTR
0086 9400              SUBB    A,#00H
0088 22                RET     
0089         L?0137:
0089         L?0138:
0089 F0                MOVX    @DPTR,A
008A 900000      R     MOV     DPTR,#CpuTouchStep
008D E0                MOVX    A,@DPTR
008E 04                INC     A
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 37  

008F F0                MOVX    @DPTR,A
0090         L?0139:
0090 900000      R     MOV     DPTR,#temp
0093 E4                CLR     A
0094 F0                MOVX    @DPTR,A
0095 A3                INC     DPTR
0096 F0                MOVX    @DPTR,A
0097 22                RET     
0098         L?0140:
0098         L?0141:
0098 850082      R     MOV     DPL,regTW88+01H
009B 850083      R     MOV     DPH,regTW88
009E A3                INC     DPTR
009F A3                INC     DPTR
00A0 22                RET     
             ; FUNCTION Com007B (END)

             ; FUNCTION ext0_int (BEGIN)
0000 C0E0              PUSH    ACC
0002 C083              PUSH    DPH
0004 C082              PUSH    DPL
0006 C085              PUSH    DPH1
0008 C084              PUSH    DPL1
000A C086              PUSH    DPS
000C 758600            MOV     DPS,#00H
000F C0D0              PUSH    PSW
0011 75D008            MOV     PSW,#08H
                                           ; SOURCE LINE # 195
                                           ; SOURCE LINE # 199
0014 C2A8              CLR     SFR_EX0
                                           ; SOURCE LINE # 211
0016 120000      R     LCALL   L?0140
0019 E0                MOVX    A,@DPTR
001A F500        R     MOV     INT_STATUS,A
                                           ; SOURCE LINE # 212
001C 120000      R     LCALL   L?0140
001F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 214
0020 E500        R     MOV     A,regTW88+01H
0022 2404              ADD     A,#04H
0024 120000      R     LCALL   L?0126
0027 E0                MOVX    A,@DPTR
0028 F500        R     MOV     INT_STATUS2,A
                                           ; SOURCE LINE # 215
002A 5407              ANL     A,#07H
002C FF                MOV     R7,A
002D E500        R     MOV     A,regTW88+01H
002F 2404              ADD     A,#04H
0031 120000      R     LCALL   L?0126
0034 EF                MOV     A,R7
0035 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 217
0036 E500        R     MOV     A,INT_STATUS
0038 30E108            JNB     ACC.1,?C0001
                                           ; SOURCE LINE # 218
003B 0500        R     INC     VH_Loss_Changed+01H
003D E500        R     MOV     A,VH_Loss_Changed+01H
003F 7002              JNZ     ?C0102
0041 0500        R     INC     VH_Loss_Changed
0043         ?C0102:
0043         ?C0001:
                                           ; SOURCE LINE # 220
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 38  

0043 E500        R     MOV     A,INT_STATUS
0045 4200        R     ORL     INT_STATUS_ACC,A
                                           ; SOURCE LINE # 221
0047 E500        R     MOV     A,INT_STATUS2
0049 4200        R     ORL     INT_STATUS2_ACC,A
                                           ; SOURCE LINE # 225
004B D2A8              SETB    SFR_EX0
                                           ; SOURCE LINE # 226
004D D0D0              POP     PSW
004F D086              POP     DPS
0051 D084              POP     DPL1
0053 D085              POP     DPH1
0055 D082              POP     DPL
0057 D083              POP     DPH
0059 D0E0              POP     ACC
005B 32                RETI    
             ; FUNCTION ext0_int (END)

             ; FUNCTION timer0_int (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C0D0              PUSH    PSW
0006 75D008            MOV     PSW,#08H
                                           ; SOURCE LINE # 264
                                           ; SOURCE LINE # 270
0009 C2A9              CLR     SFR_ET0
                                           ; SOURCE LINE # 274
000B 0500        R     INC     tic01
                                           ; SOURCE LINE # 276
000D E500        R     MOV     A,tic01
000F 75F00A            MOV     B,#0AH
0012 84                DIV     AB
0013 85F000      R     MOV     tic01,B
                                           ; SOURCE LINE # 277
0016 E500        R     MOV     A,tic01
0018 7037              JNZ     ?C0003
                                           ; SOURCE LINE # 278
001A E500        R     MOV     A,SystemClock+03H
001C 2401              ADD     A,#01H
001E F500        R     MOV     SystemClock+03H,A
0020 E4                CLR     A
0021 3500        R     ADDC    A,SystemClock+02H
0023 F500        R     MOV     SystemClock+02H,A
0025 E4                CLR     A
0026 3500        R     ADDC    A,SystemClock+01H
0028 F500        R     MOV     SystemClock+01H,A
002A E4                CLR     A
002B 3500        R     ADDC    A,SystemClock
002D F500        R     MOV     SystemClock,A
                                           ; SOURCE LINE # 279
002F AF00        R     MOV     R7,OsdTimerClock+03H
0031 AE00        R     MOV     R6,OsdTimerClock+02H
0033 AD00        R     MOV     R5,OsdTimerClock+01H
0035 AC00        R     MOV     R4,OsdTimerClock
0037 EC                MOV     A,R4
0038 4D                ORL     A,R5
0039 4E                ORL     A,R6
003A 4F                ORL     A,R7
003B 6014              JZ      ?C0003
                                           ; SOURCE LINE # 280
003D EF                MOV     A,R7
003E 24FF              ADD     A,#0FFH
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 39  

0040 F500        R     MOV     OsdTimerClock+03H,A
0042 EE                MOV     A,R6
0043 34FF              ADDC    A,#0FFH
0045 F500        R     MOV     OsdTimerClock+02H,A
0047 ED                MOV     A,R5
0048 34FF              ADDC    A,#0FFH
004A F500        R     MOV     OsdTimerClock+01H,A
004C EC                MOV     A,R4
004D 34FF              ADDC    A,#0FFH
004F F500        R     MOV     OsdTimerClock,A
                                           ; SOURCE LINE # 292
0051         ?C0003:
                                           ; SOURCE LINE # 293
0051 0500        R     INC     tic_pc+01H
0053 E500        R     MOV     A,tic_pc+01H
0055 7002              JNZ     ?C0103
0057 0500        R     INC     tic_pc
0059         ?C0103:
                                           ; SOURCE LINE # 294
0059 0500        R     INC     tic_task+01H
005B E500        R     MOV     A,tic_task+01H
005D 7002              JNZ     ?C0104
005F 0500        R     INC     tic_task
0061         ?C0104:
                                           ; SOURCE LINE # 307
0061 D2A9              SETB    SFR_ET0
                                           ; SOURCE LINE # 308
0063 D0D0              POP     PSW
0065 D0F0              POP     B
0067 D0E0              POP     ACC
0069 32                RETI    
             ; FUNCTION timer0_int (END)

             ; FUNCTION ext1_int (BEGIN)
                                           ; SOURCE LINE # 313
                                           ; SOURCE LINE # 318
0000 C2AA              CLR     SFR_EX1
                                           ; SOURCE LINE # 319
0002 32                RETI    
             ; FUNCTION ext1_int (END)

             ; FUNCTION timer1_int (BEGIN)
0000 C0E0              PUSH    ACC
0002 C083              PUSH    DPH
0004 C082              PUSH    DPL
0006 C085              PUSH    DPH1
0008 C084              PUSH    DPL1
000A C086              PUSH    DPS
000C 758600            MOV     DPS,#00H
000F C0D0              PUSH    PSW
0011 75D008            MOV     PSW,#08H
                                           ; SOURCE LINE # 356
;---- Variable 'TscData' assigned to Register 'R2/R3' ----
                                           ; SOURCE LINE # 365
0014 C2AB              CLR     SFR_ET1
                                           ; SOURCE LINE # 367
0016 900000      R     MOV     DPTR,#CpuTouchSkipCount
0019 E0                MOVX    A,@DPTR
001A 7002              JNZ     ?C0105
001C A3                INC     DPTR
001D E0                MOVX    A,@DPTR
001E         ?C0105:
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 40  

001E 6013              JZ      ?C0007
                                           ; SOURCE LINE # 368
0020 900000      R     MOV     DPTR,#CpuTouchSkipCount+01H
0023 E0                MOVX    A,@DPTR
0024 24FF              ADD     A,#0FFH
0026 F0                MOVX    @DPTR,A
0027 900000      R     MOV     DPTR,#CpuTouchSkipCount
002A E0                MOVX    A,@DPTR
002B 34FF              ADDC    A,#0FFH
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 369
002E D2AB              SETB    SFR_ET1
0030 020000      R     LJMP    ?C0008
                                           ; SOURCE LINE # 371
0033         ?C0007:
                                           ; SOURCE LINE # 376
0033 900000      R     MOV     DPTR,#CpuTouchStep
0036 E0                MOVX    A,@DPTR
0037 FD                MOV     R5,A
0038 702D              JNZ     ?C0009
                                           ; SOURCE LINE # 378
003A 120000      R     LCALL   L?0124
003D E0                MOVX    A,@DPTR
003E 2B                ADD     A,R3
003F FB                MOV     R3,A
0040 E4                CLR     A
0041 3A                ADDC    A,R2
0042 FA                MOV     R2,A
                                           ; SOURCE LINE # 379
0043 D3                SETB    C
0044 EB                MOV     A,R3
0045 9400              SUBB    A,#00H
0047 EA                MOV     A,R2
0048 9408              SUBB    A,#08H
004A 4012              JC      ?C0010
                                           ; SOURCE LINE # 380
004C E500        R     MOV     A,regTW88+01H
004E 24B0              ADD     A,#0B0H
0050 120000      R     LCALL   L?0126
0053 7401              MOV     A,#01H
                                           ; SOURCE LINE # 381
                                           ; SOURCE LINE # 382
0055 120000      R     LCALL   L?0137
                                           ; SOURCE LINE # 383
0058 900000      R     MOV     DPTR,#CpuZ2
                                           ; SOURCE LINE # 384
005B 020000      R     LJMP    ?C0121
005E         ?C0010:
                                           ; SOURCE LINE # 385
                                           ; SOURCE LINE # 386
005E 900000      R     MOV     DPTR,#CpuTouchStep
0061 7405              MOV     A,#05H
0063 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 387
                                           ; SOURCE LINE # 388
0064 020000      R     LJMP    ?C0012
0067         ?C0009:
                                           ; SOURCE LINE # 389
0067 ED                MOV     A,R5
0068 6401              XRL     A,#01H
006A 703D              JNZ     ?C0013
                                           ; SOURCE LINE # 391
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 41  

006C 120000      R     LCALL   L?0124
                                           ; SOURCE LINE # 392
006F 120000      R     LCALL   L?0131
0072 5005              JNC     ?C0014
0074 120000      R     LCALL   L?0133
0077 8003              SJMP    ?C0015
0079         ?C0014:
                                           ; SOURCE LINE # 393
0079 120000      R     LCALL   L?0129
007C         ?C0015:
                                           ; SOURCE LINE # 395
007C 120000      R     LCALL   L?0135
007F 5022              JNC     ?C0016
                                           ; SOURCE LINE # 396
0081 C3                CLR     C
0082 EB                MOV     A,R3
0083 9464              SUBB    A,#064H
0085 EA                MOV     A,R2
0086 9400              SUBB    A,#00H
0088 500E              JNC     ?C0017
                                           ; SOURCE LINE # 397
008A C200        R     CLR     CpuTouchPressed
                                           ; SOURCE LINE # 398
008C 900000      R     MOV     DPTR,#CpuTouchStep
008F 7405              MOV     A,#05H
0091 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 399
0092 900000      R     MOV     DPTR,#CpuTouchChanged
                                           ; SOURCE LINE # 400
0095 020000      R     LJMP    ?C0116
0098         ?C0017:
                                           ; SOURCE LINE # 401
                                           ; SOURCE LINE # 402
0098 E500        R     MOV     A,regTW88+01H
009A 24B0              ADD     A,#0B0H
009C 120000      R     LCALL   L?0126
009F E4                CLR     A
                                           ; SOURCE LINE # 403
                                           ; SOURCE LINE # 404
                                           ; SOURCE LINE # 405
                                           ; SOURCE LINE # 406
00A0 020000      R     LJMP    ?C0117
00A3         ?C0016:
                                           ; SOURCE LINE # 407
                                           ; SOURCE LINE # 408
00A3 900000      R     MOV     DPTR,#temp
00A6         ?C0115:
                                           ; SOURCE LINE # 410
                                           ; SOURCE LINE # 411
00A6 020000      R     LJMP    ?C0121
00A9         ?C0013:
                                           ; SOURCE LINE # 412
00A9 900000      R     MOV     DPTR,#CpuTouchStep
00AC E0                MOVX    A,@DPTR
00AD F9                MOV     R1,A
00AE 6402              XRL     A,#02H
00B0 702C              JNZ     ?C0021
                                           ; SOURCE LINE # 414
00B2 120000      R     LCALL   L?0125
                                           ; SOURCE LINE # 416
00B5 120000      R     LCALL   L?0131
00B8 5005              JNC     ?C0022
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 42  

00BA 120000      R     LCALL   L?0133
00BD 8003              SJMP    ?C0023
00BF         ?C0022:
                                           ; SOURCE LINE # 417
00BF 120000      R     LCALL   L?0129
00C2         ?C0023:
                                           ; SOURCE LINE # 419
00C2 120000      R     LCALL   L?0135
00C5 5011              JNC     ?C0024
                                           ; SOURCE LINE # 420
00C7 E500        R     MOV     A,regTW88+01H
00C9 24B0              ADD     A,#0B0H
00CB 120000      R     LCALL   L?0126
00CE 7403              MOV     A,#03H
                                           ; SOURCE LINE # 421
                                           ; SOURCE LINE # 422
00D0 120000      R     LCALL   L?0137
                                           ; SOURCE LINE # 423
00D3 900000      R     MOV     DPTR,#TX
                                           ; SOURCE LINE # 424
00D6 8003              SJMP    ?C0113
00D8         ?C0024:
                                           ; SOURCE LINE # 425
                                           ; SOURCE LINE # 426
00D8 900000      R     MOV     DPTR,#temp
00DB         ?C0113:
00DB         ?C0118:
                                           ; SOURCE LINE # 428
                                           ; SOURCE LINE # 429
00DB 020000      R     LJMP    ?C0121
00DE         ?C0021:
                                           ; SOURCE LINE # 430
00DE E9                MOV     A,R1
00DF 6403              XRL     A,#03H
00E1 7033              JNZ     ?C0027
                                           ; SOURCE LINE # 432
00E3 120000      R     LCALL   L?0125
                                           ; SOURCE LINE # 434
00E6 120000      R     LCALL   L?0132
00E9 5005              JNC     ?C0028
00EB 120000      R     LCALL   L?0134
00EE 8003              SJMP    ?C0029
00F0         ?C0028:
                                           ; SOURCE LINE # 435
00F0 120000      R     LCALL   L?0130
00F3         ?C0029:
                                           ; SOURCE LINE # 437
00F3 120000      R     LCALL   L?0136
00F6 5018              JNC     ?C0030
                                           ; SOURCE LINE # 438
00F8 E500        R     MOV     A,regTW88+01H
00FA 24B0              ADD     A,#0B0H
00FC 120000      R     LCALL   L?0126
00FF 7401              MOV     A,#01H
0101 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 439
0102 120000      R     LCALL   L?0139
                                           ; SOURCE LINE # 440
0105 900000      R     MOV     DPTR,#CpuTouchStep
0108 E0                MOVX    A,@DPTR
0109 04                INC     A
010A F0                MOVX    @DPTR,A
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 43  

                                           ; SOURCE LINE # 441
010B 900000      R     MOV     DPTR,#TY
                                           ; SOURCE LINE # 442
010E 8003              SJMP    ?C0114
0110         ?C0030:
                                           ; SOURCE LINE # 443
                                           ; SOURCE LINE # 444
0110 900000      R     MOV     DPTR,#temp
0113         ?C0114:
0113         ?C0119:
                                           ; SOURCE LINE # 446
                                           ; SOURCE LINE # 447
0113 020000      R     LJMP    ?C0121
0116         ?C0027:
                                           ; SOURCE LINE # 448
0116 E9                MOV     A,R1
0117 6404              XRL     A,#04H
0119 7065              JNZ     ?C0033
                                           ; SOURCE LINE # 450
011B 120000      R     LCALL   L?0125
                                           ; SOURCE LINE # 452
011E 120000      R     LCALL   L?0132
0121 5005              JNC     ?C0034
0123 120000      R     LCALL   L?0134
0126 8003              SJMP    ?C0035
0128         ?C0034:
                                           ; SOURCE LINE # 453
0128 120000      R     LCALL   L?0130
012B         ?C0035:
                                           ; SOURCE LINE # 455
012B 120000      R     LCALL   L?0136
012E 504A              JNC     ?C0036
                                           ; SOURCE LINE # 456
0130 C3                CLR     C
0131 EB                MOV     A,R3
0132 9464              SUBB    A,#064H
0134 EA                MOV     A,R2
0135 9400              SUBB    A,#00H
0137 500A              JNC     ?C0037
                                           ; SOURCE LINE # 457
0139 C200        R     CLR     CpuTouchPressed
                                           ; SOURCE LINE # 458
013B 900000      R     MOV     DPTR,#CpuTouchChanged
013E E0                MOVX    A,@DPTR
013F 04                INC     A
0140 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 459
0141 802E              SJMP    ?C0038
0143         ?C0037:
                                           ; SOURCE LINE # 460
                                           ; SOURCE LINE # 464
0143 900000      R     MOV     DPTR,#TX
0146 E0                MOVX    A,@DPTR
0147 FF                MOV     R7,A
0148 A3                INC     DPTR
0149 E0                MOVX    A,@DPTR
014A 900000      R     MOV     DPTR,#CpuTouchX
014D CF                XCH     A,R7
014E F0                MOVX    @DPTR,A
014F A3                INC     DPTR
0150 EF                MOV     A,R7
0151 F0                MOVX    @DPTR,A
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 44  

                                           ; SOURCE LINE # 465
0152 900000      R     MOV     DPTR,#TY
0155 E0                MOVX    A,@DPTR
0156 FF                MOV     R7,A
0157 A3                INC     DPTR
0158 E0                MOVX    A,@DPTR
0159 900000      R     MOV     DPTR,#CpuTouchY
015C CF                XCH     A,R7
015D F0                MOVX    @DPTR,A
015E A3                INC     DPTR
015F EF                MOV     A,R7
0160 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 466
0161 900000      R     MOV     DPTR,#CpuZ1
0164 EA                MOV     A,R2
0165 F0                MOVX    @DPTR,A
0166 A3                INC     DPTR
0167 EB                MOV     A,R3
0168 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 467
0169 900000      R     MOV     DPTR,#CpuTouchChanged
016C E0                MOVX    A,@DPTR
016D 04                INC     A
016E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 468
016F D200        R     SETB    CpuTouchPressed
                                           ; SOURCE LINE # 469
0171         ?C0038:
                                           ; SOURCE LINE # 470
0171 900000      R     MOV     DPTR,#CpuTouchStep
0174         ?C0116:
0174 E0                MOVX    A,@DPTR
0175 04                INC     A
0176 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 471
0177 020000      R     LJMP    ?C0012
017A         ?C0036:
                                           ; SOURCE LINE # 472
                                           ; SOURCE LINE # 473
017A 900000      R     MOV     DPTR,#temp
017D         ?C0120:
                                           ; SOURCE LINE # 475
                                           ; SOURCE LINE # 476
017D 020000      R     LJMP    ?C0121
0180         ?C0033:
                                           ; SOURCE LINE # 477
0180 E9                MOV     A,R1
0181 B4050F            CJNE    A,#05H,?C0041
                                           ; SOURCE LINE # 478
0184 E500        R     MOV     A,regTW88+01H
0186 24B0              ADD     A,#0B0H
0188 120000      R     LCALL   L?0126
018B 7407              MOV     A,#07H
018D         ?C0117:
                                           ; SOURCE LINE # 479
                                           ; SOURCE LINE # 480
018D 120000      R     LCALL   L?0138
                                           ; SOURCE LINE # 481
0190 020000      R     LJMP    ?C0012
0193         ?C0041:
                                           ; SOURCE LINE # 482
0193 E9                MOV     A,R1
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 45  

0194 6406              XRL     A,#06H
0196 703E              JNZ     ?C0012
                                           ; SOURCE LINE # 484
0198 120000      R     LCALL   L?0125
                                           ; SOURCE LINE # 486
019B 120000      R     LCALL   L?0132
019E 5005              JNC     ?C0044
01A0 120000      R     LCALL   L?0134
01A3 8003              SJMP    ?C0045
01A5         ?C0044:
                                           ; SOURCE LINE # 487
01A5 120000      R     LCALL   L?0130
01A8         ?C0045:
                                           ; SOURCE LINE # 489
01A8 120000      R     LCALL   L?0136
01AB 5021              JNC     ?C0046
                                           ; SOURCE LINE # 490
01AD 900000      R     MOV     DPTR,#CpuAUX3
01B0 EA                MOV     A,R2
01B1 F0                MOVX    @DPTR,A
01B2 A3                INC     DPTR
01B3 EB                MOV     A,R3
01B4 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 491
01B5 900000      R     MOV     DPTR,#CpuAUX3_Changed
01B8 E0                MOVX    A,@DPTR
01B9 04                INC     A
01BA F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 492
01BB E500        R     MOV     A,regTW88+01H
01BD 24B0              ADD     A,#0B0H
01BF 120000      R     LCALL   L?0126
01C2 7402              MOV     A,#02H
01C4 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 493
01C5 120000      R     LCALL   L?0139
                                           ; SOURCE LINE # 494
01C8 900000      R     MOV     DPTR,#CpuTouchStep
01CB F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 495
01CC 8008              SJMP    ?C0012
01CE         ?C0046:
                                           ; SOURCE LINE # 496
                                           ; SOURCE LINE # 497
01CE 900000      R     MOV     DPTR,#temp
01D1         ?C0121:
01D1 EA                MOV     A,R2
01D2 F0                MOVX    @DPTR,A
01D3 A3                INC     DPTR
01D4 EB                MOV     A,R3
01D5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 499
                                           ; SOURCE LINE # 501
01D6         ?C0012:
                                           ; SOURCE LINE # 503
01D6 D2AB              SETB    SFR_ET1
                                           ; SOURCE LINE # 507
01D8         ?C0008:
01D8 D0D0              POP     PSW
01DA D086              POP     DPS
01DC D084              POP     DPL1
01DE D085              POP     DPH1
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 46  

01E0 D082              POP     DPL
01E2 D083              POP     DPH
01E4 D0E0              POP     ACC
01E6 32                RETI    
             ; FUNCTION timer1_int (END)

             ; FUNCTION uart0_int (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0D0              PUSH    PSW
0004 75D008            MOV     PSW,#08H
                                           ; SOURCE LINE # 519
                                           ; SOURCE LINE # 525
0007 C2AC              CLR     SFR_ES
                                           ; SOURCE LINE # 530
0009 309816            JNB     SFR_RI,?C0048
                                           ; SOURCE LINE # 531
000C C298              CLR     SFR_RI
                                           ; SOURCE LINE # 548
                                           ; SOURCE LINE # 549
000E AF00        R     MOV     R7,RS_in
0010 0500        R     INC     RS_in
0012 7400        R     MOV     A,#LOW RS_buf
0014 2F                ADD     A,R7
0015 F8                MOV     R0,A
0016 A699              MOV     @R0,SFR_SBUF
                                           ; SOURCE LINE # 550
0018 E500        R     MOV     A,RS_in
001A C3                CLR     C
001B 9420              SUBB    A,#020H
001D 4003              JC      ?C0048
001F 750000      R     MOV     RS_in,#00H
                                           ; SOURCE LINE # 551
                                           ; SOURCE LINE # 552
0022         ?C0048:
                                           ; SOURCE LINE # 554
0022 309904            JNB     SFR_TI,?C0050
                                           ; SOURCE LINE # 555
0025 C299              CLR     SFR_TI
                                           ; SOURCE LINE # 556
0027 C200        R     CLR     RS_Xbusy
                                           ; SOURCE LINE # 557
0029         ?C0050:
                                           ; SOURCE LINE # 558
0029 D2AC              SETB    SFR_ES
                                           ; SOURCE LINE # 559
002B D0D0              POP     PSW
002D D0E0              POP     ACC
002F 32                RETI    
             ; FUNCTION uart0_int (END)

             ; FUNCTION timer2_int (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C083              PUSH    DPH
0006 C082              PUSH    DPL
0008 C085              PUSH    DPH1
000A C084              PUSH    DPL1
000C C086              PUSH    DPS
000E 758600            MOV     DPS,#00H
0011 C0D0              PUSH    PSW
0013 75D008            MOV     PSW,#08H
                                           ; SOURCE LINE # 575
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 47  

                                           ; SOURCE LINE # 580
0016 C2AD              CLR     SFR_ET2
                                           ; SOURCE LINE # 584
0018 53C9FC            ANL     SFR_T2IF,#0FCH
                                           ; SOURCE LINE # 586
001B 0500        R     INC     RemoTic+01H
001D E500        R     MOV     A,RemoTic+01H
001F 7002              JNZ     ?C0106
0021 0500        R     INC     RemoTic
0023         ?C0106:
                                           ; SOURCE LINE # 587
0023 A292              MOV     C,P1_2
0025 9200        R     MOV     sample,C
                                           ; SOURCE LINE # 613
0027 5407              ANL     A,#07H
0029 FF                MOV     R7,A
;---- Variable 'i' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 614
002A B40106            CJNE    A,#01H,?C0052
002D A200        R     MOV     C,sample
002F 9200        R     MOV     RemoPhase1,C
0031 806C              SJMP    ?C0053
0033         ?C0052:
                                           ; SOURCE LINE # 615
0033 EF                MOV     A,R7
0034 B40506            CJNE    A,#05H,?C0054
0037 A200        R     MOV     C,sample
0039 9200        R     MOV     RemoPhase2,C
003B 8062              SJMP    ?C0053
003D         ?C0054:
                                           ; SOURCE LINE # 618
003D EF                MOV     A,R7
003E 705F              JNZ     ?C0053
                                           ; SOURCE LINE # 619
0040 A200        R     MOV     C,RemoPhase1
0042 300001      R     JNB     RemoPhase2,?C0107
0045 B3                CPL     C
0046         ?C0107:
0046 400E              JC      ?C0057
                                           ; SOURCE LINE # 620
0048 75C800            MOV     SFR_T2CON,#00H
                                           ; SOURCE LINE # 621
004B 7800        R     MOV     R0,#LOW RemoDataReady
004D 7600              MOV     @R0,#00H
004F 43FB04            ORL     SFR_E2IE,#04H
                                           ; SOURCE LINE # 623
0052 D2AD              SETB    SFR_ET2
0054 804B              SJMP    ?C0058
                                           ; SOURCE LINE # 626
0056         ?C0057:
                                           ; SOURCE LINE # 627
0056 D3                SETB    C
0057 E500        R     MOV     A,RemoTic+01H
0059 9440              SUBB    A,#040H
005B E500        R     MOV     A,RemoTic
005D 9400              SUBB    A,#00H
005F 500F              JNC     ?C0059
                                           ; SOURCE LINE # 628
0061 7800        R     MOV     R0,#LOW RemoSystemCode
0063 E6                MOV     A,@R0
0064 FF                MOV     R7,A
0065 25E0              ADD     A,ACC
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 48  

0067 F6                MOV     @R0,A
                                           ; SOURCE LINE # 629
0068 300016      R     JNB     RemoPhase1,?C0061
006B 200013      R     JB      RemoPhase2,?C0061
                                           ; SOURCE LINE # 630
                                           ; SOURCE LINE # 631
006E 800D              SJMP    ?C0122
0070         ?C0059:
                                           ; SOURCE LINE # 632
                                           ; SOURCE LINE # 633
0070 7800        R     MOV     R0,#LOW RemoDataCode
0072 E6                MOV     A,@R0
0073 FF                MOV     R7,A
0074 25E0              ADD     A,ACC
0076 F6                MOV     @R0,A
                                           ; SOURCE LINE # 634
0077 300007      R     JNB     RemoPhase1,?C0061
007A 200004      R     JB      RemoPhase2,?C0061
                                           ; SOURCE LINE # 635
007D         ?C0122:
007D E6                MOV     A,@R0
007E 4401              ORL     A,#01H
0080 F6                MOV     @R0,A
                                           ; SOURCE LINE # 636
0081         ?C0061:
                                           ; SOURCE LINE # 638
0081 C3                CLR     C
0082 E500        R     MOV     A,RemoTic+01H
0084 9470              SUBB    A,#070H
0086 E500        R     MOV     A,RemoTic
0088 9400              SUBB    A,#00H
008A 4013              JC      ?C0053
                                           ; SOURCE LINE # 639
008C 7800        R     MOV     R0,#LOW RemoDataReady
008E 06                INC     @R0
                                           ; SOURCE LINE # 646
008F AF00        R     MOV     R7,SystemClock+03H
0091 AE00        R     MOV     R6,SystemClock+02H
0093 AD00        R     MOV     R5,SystemClock+01H
0095 AC00        R     MOV     R4,SystemClock
0097 7800        R     MOV     R0,#LOW RemoReceivedTime
0099 120000      E     LCALL   ?C?LSTIDATA
                                           ; SOURCE LINE # 650
009C 75C800            MOV     SFR_T2CON,#00H
                                           ; SOURCE LINE # 651
                                           ; SOURCE LINE # 652
009F         ?C0053:
                                           ; SOURCE LINE # 653
009F D2AD              SETB    SFR_ET2
                                           ; SOURCE LINE # 654
00A1         ?C0058:
00A1 D0D0              POP     PSW
00A3 D086              POP     DPS
00A5 D084              POP     DPL1
00A7 D085              POP     DPH1
00A9 D082              POP     DPL
00AB D083              POP     DPH
00AD D0F0              POP     B
00AF D0E0              POP     ACC
00B1 32                RETI    
             ; FUNCTION timer2_int (END)

C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 49  

             ; FUNCTION ext2_int (BEGIN)
0000 C0E0              PUSH    ACC
0002 C083              PUSH    DPH
0004 C082              PUSH    DPL
0006 C085              PUSH    DPH1
0008 C084              PUSH    DPL1
000A C086              PUSH    DPS
000C 758600            MOV     DPS,#00H
                                           ; SOURCE LINE # 849
                                           ; SOURCE LINE # 854
000F C2AA              CLR     SFR_EX1
                                           ; SOURCE LINE # 861
0011 120000      R     LCALL   L?0141
0014 E0                MOVX    A,@DPTR
0015 900000      R     MOV     DPTR,#val
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 862
0019 120000      R     LCALL   L?0141
001C 7480              MOV     A,#080H
001E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 865
001F D2AA              SETB    SFR_EX1
                                           ; SOURCE LINE # 866
0021 D086              POP     DPS
0023 D084              POP     DPL1
0025 D085              POP     DPH1
0027 D082              POP     DPL
0029 D083              POP     DPH
002B D0E0              POP     ACC
002D 32                RETI    
             ; FUNCTION ext2_int (END)

             ; FUNCTION ext3_int (BEGIN)
                                           ; SOURCE LINE # 872
                                           ; SOURCE LINE # 877
0000 32                RETI    
             ; FUNCTION ext3_int (END)

             ; FUNCTION ext4_int (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C083              PUSH    DPH
0006 C082              PUSH    DPL
0008 C085              PUSH    DPH1
000A C084              PUSH    DPL1
000C C086              PUSH    DPS
000E 758600            MOV     DPS,#00H
0011 C0D0              PUSH    PSW
0013 75D008            MOV     PSW,#08H
                                           ; SOURCE LINE # 881
                                           ; SOURCE LINE # 883
0016 C2EA              CLR     SFR_EINT4
                                           ; SOURCE LINE # 887
0018 120000      R     LCALL   L?0127
                                           ; SOURCE LINE # 896
001B D0D0              POP     PSW
001D D086              POP     DPS
001F D084              POP     DPL1
0021 D085              POP     DPH1
0023 D082              POP     DPL
0025 D083              POP     DPH
0027 D0F0              POP     B
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 50  

0029 D0E0              POP     ACC
002B 32                RETI    
             ; FUNCTION ext4_int (END)

             ; FUNCTION ext5_int (BEGIN)
                                           ; SOURCE LINE # 900
                                           ; SOURCE LINE # 905
0000 32                RETI    
             ; FUNCTION ext5_int (END)

             ; FUNCTION ext6_int (BEGIN)
                                           ; SOURCE LINE # 909
                                           ; SOURCE LINE # 914
0000 32                RETI    
             ; FUNCTION ext6_int (END)

             ; FUNCTION watchdog_int (BEGIN)
                                           ; SOURCE LINE # 925
                                           ; SOURCE LINE # 927
0000 C2ED              CLR     SFR_EWDI
                                           ; SOURCE LINE # 937
0002 75EBAA            MOV     SFR_TA,#0AAH
                                           ; SOURCE LINE # 938
0005 75EB55            MOV     SFR_TA,#055H
                                           ; SOURCE LINE # 939
0008 75D803            MOV     SFR_WDCON,#03H
                                           ; SOURCE LINE # 941
000B D2ED              SETB    SFR_EWDI
                                           ; SOURCE LINE # 942
000D 32                RETI    
             ; FUNCTION watchdog_int (END)

             ; FUNCTION ext7_int (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C083              PUSH    DPH
0006 C082              PUSH    DPL
0008 C085              PUSH    DPH1
000A C084              PUSH    DPL1
000C C086              PUSH    DPS
000E 758600            MOV     DPS,#00H
0011 C0D0              PUSH    PSW
0013 75D008            MOV     PSW,#08H
                                           ; SOURCE LINE # 949
                                           ; SOURCE LINE # 951
0016 C2AF              CLR     SFR_EA
                                           ; SOURCE LINE # 952
0018 430001      R     ORL     EXINT_STATUS,#01H
                                           ; SOURCE LINE # 953
001B 120000      R     LCALL   L?0127
                                           ; SOURCE LINE # 955
001E 75FA01            MOV     SFR_E2IF,#01H
                                           ; SOURCE LINE # 956
0021 D2AF              SETB    SFR_EA
                                           ; SOURCE LINE # 957
0023 D0D0              POP     PSW
0025 D086              POP     DPS
0027 D084              POP     DPL1
0029 D085              POP     DPH1
002B D082              POP     DPL
002D D083              POP     DPH
002F D0F0              POP     B
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 51  

0031 D0E0              POP     ACC
0033 32                RETI    
             ; FUNCTION ext7_int (END)

             ; FUNCTION ext8_int (BEGIN)
                                           ; SOURCE LINE # 961
                                           ; SOURCE LINE # 963
0000 C2AF              CLR     SFR_EA
                                           ; SOURCE LINE # 964
0002 430002      R     ORL     EXINT_STATUS,#02H
                                           ; SOURCE LINE # 966
0005 75FA02            MOV     SFR_E2IF,#02H
                                           ; SOURCE LINE # 967
0008 D2AF              SETB    SFR_EA
                                           ; SOURCE LINE # 968
000A 32                RETI    
             ; FUNCTION ext8_int (END)

             ; FUNCTION ext9_int (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C083              PUSH    DPH
0006 C082              PUSH    DPL
0008 C085              PUSH    DPH1
000A C084              PUSH    DPL1
000C C086              PUSH    DPS
000E 758600            MOV     DPS,#00H
0011 C0D0              PUSH    PSW
0013 75D008            MOV     PSW,#08H
                                           ; SOURCE LINE # 972
                                           ; SOURCE LINE # 974
0016 C2AF              CLR     SFR_EA
                                           ; SOURCE LINE # 975
0018 430004      R     ORL     EXINT_STATUS,#04H
                                           ; SOURCE LINE # 976
001B 120000      R     LCALL   L?0128
                                           ; SOURCE LINE # 978
001E 53FBFB            ANL     SFR_E2IE,#0FBH
                                           ; SOURCE LINE # 979
0021 75FA04            MOV     SFR_E2IF,#04H
                                           ; SOURCE LINE # 981
0024 120000      R     LCALL   InitRemoTimer
                                           ; SOURCE LINE # 982
0027 D2AF              SETB    SFR_EA
                                           ; SOURCE LINE # 983
0029 D0D0              POP     PSW
002B D086              POP     DPS
002D D084              POP     DPL1
002F D085              POP     DPH1
0031 D082              POP     DPL
0033 D083              POP     DPH
0035 D0F0              POP     B
0037 D0E0              POP     ACC
0039 32                RETI    
             ; FUNCTION ext9_int (END)

             ; FUNCTION ext10_int (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C083              PUSH    DPH
0006 C082              PUSH    DPL
0008 C085              PUSH    DPH1
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 52  

000A C084              PUSH    DPL1
000C C086              PUSH    DPS
000E 758600            MOV     DPS,#00H
0011 C0D0              PUSH    PSW
0013 75D008            MOV     PSW,#08H
                                           ; SOURCE LINE # 1008
                                           ; SOURCE LINE # 1011
0016 C2AF              CLR     SFR_EA
                                           ; SOURCE LINE # 1012
0018 430008      R     ORL     EXINT_STATUS,#08H
                                           ; SOURCE LINE # 1013
001B 120000      R     LCALL   L?0128
                                           ; SOURCE LINE # 1015
001E 75FA08            MOV     SFR_E2IF,#08H
                                           ; SOURCE LINE # 1027
0021 D2AF              SETB    SFR_EA
                                           ; SOURCE LINE # 1029
0023 D0D0              POP     PSW
0025 D086              POP     DPS
0027 D084              POP     DPL1
0029 D085              POP     DPH1
002B D082              POP     DPL
002D D083              POP     DPH
002F D0F0              POP     B
0031 D0E0              POP     ACC
0033 32                RETI    
             ; FUNCTION ext10_int (END)

             ; FUNCTION ext11_int (BEGIN)
                                           ; SOURCE LINE # 1035
                                           ; SOURCE LINE # 1037
0000 C2AF              CLR     SFR_EA
                                           ; SOURCE LINE # 1038
0002 430010      R     ORL     EXINT_STATUS,#010H
                                           ; SOURCE LINE # 1040
0005 75FA10            MOV     SFR_E2IF,#010H
                                           ; SOURCE LINE # 1041
0008 D2AF              SETB    SFR_EA
                                           ; SOURCE LINE # 1042
000A 32                RETI    
             ; FUNCTION ext11_int (END)

             ; FUNCTION ext12_int (BEGIN)
                                           ; SOURCE LINE # 1047
                                           ; SOURCE LINE # 1049
0000 C2AF              CLR     SFR_EA
                                           ; SOURCE LINE # 1050
0002 430020      R     ORL     EXINT_STATUS,#020H
                                           ; SOURCE LINE # 1052
0005 75FA20            MOV     SFR_E2IF,#020H
                                           ; SOURCE LINE # 1053
0008 D2AF              SETB    SFR_EA
                                           ; SOURCE LINE # 1054
000A 32                RETI    
             ; FUNCTION ext12_int (END)

             ; FUNCTION ext13_int (BEGIN)
                                           ; SOURCE LINE # 1216
                                           ; SOURCE LINE # 1218
0000 C2AF              CLR     SFR_EA
                                           ; SOURCE LINE # 1219
0002 430040      R     ORL     EXINT_STATUS,#040H
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 53  

                                           ; SOURCE LINE # 1221
0005 75FA40            MOV     SFR_E2IF,#040H
                                           ; SOURCE LINE # 1222
0008 D2AF              SETB    SFR_EA
                                           ; SOURCE LINE # 1223
000A 32                RETI    
             ; FUNCTION ext13_int (END)

             ; FUNCTION ext14_int (BEGIN)
                                           ; SOURCE LINE # 1341
                                           ; SOURCE LINE # 1343
0000 C2AF              CLR     SFR_EA
                                           ; SOURCE LINE # 1344
0002 430080      R     ORL     EXINT_STATUS,#080H
                                           ; SOURCE LINE # 1345
0005 75FA80            MOV     SFR_E2IF,#080H
                                           ; SOURCE LINE # 1346
0008 D2AF              SETB    SFR_EA
                                           ; SOURCE LINE # 1347
000A 32                RETI    
             ; FUNCTION ext14_int (END)

             ; FUNCTION RS_ready (BEGIN)
                                           ; SOURCE LINE # 1359
                                           ; SOURCE LINE # 1360
                                           ; SOURCE LINE # 1361
0000 E500        R     MOV     A,RS_in
0002 B50003      R     CJNE    A,RS_out,?C0078
0005 7F00              MOV     R7,#00H
0007 22                RET     
0008         ?C0078:
                                           ; SOURCE LINE # 1362
0008 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 1363
000A         ?C0079:
000A 22                RET     
             ; FUNCTION RS_ready (END)

             ; FUNCTION RS_rx (BEGIN)
                                           ; SOURCE LINE # 1378
                                           ; SOURCE LINE # 1379
                                           ; SOURCE LINE # 1382
0000 C2AC              CLR     SFR_ES
                                           ; SOURCE LINE # 1383
0002 7400        R     MOV     A,#LOW RS_buf
0004 2500        R     ADD     A,RS_out
0006 F8                MOV     R0,A
0007 E6                MOV     A,@R0
0008 FF                MOV     R7,A
;---- Variable 'ret' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1384
0009 0500        R     INC     RS_out
                                           ; SOURCE LINE # 1385
000B E500        R     MOV     A,RS_out
000D C3                CLR     C
000E 9420              SUBB    A,#020H
0010 4003              JC      ?C0081
                                           ; SOURCE LINE # 1386
0012 E4                CLR     A
0013 F500        R     MOV     RS_out,A
0015         ?C0081:
                                           ; SOURCE LINE # 1387
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 54  

0015 D2AC              SETB    SFR_ES
                                           ; SOURCE LINE # 1389
                                           ; SOURCE LINE # 1390
0017         ?C0082:
0017 22                RET     
             ; FUNCTION RS_rx (END)

             ; FUNCTION _RS_ungetch (BEGIN)
                                           ; SOURCE LINE # 1394
;---- Variable 'ch' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1395
                                           ; SOURCE LINE # 1396
0000 AE00        R     MOV     R6,RS_in
0002 0500        R     INC     RS_in
0004 7400        R     MOV     A,#LOW RS_buf
0006 2E                ADD     A,R6
0007 F8                MOV     R0,A
0008 A607              MOV     @R0,AR7
                                           ; SOURCE LINE # 1397
000A E500        R     MOV     A,RS_in
000C C3                CLR     C
000D 9420              SUBB    A,#020H
000F 4003              JC      ?C0084
0011 E4                CLR     A
0012 F500        R     MOV     RS_in,A
                                           ; SOURCE LINE # 1398
0014         ?C0084:
0014 22                RET     
             ; FUNCTION _RS_ungetch (END)

             ; FUNCTION _RS_tx (BEGIN)
                                           ; SOURCE LINE # 1426
;---- Variable 'tx_buf' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1427
0000         ?C0085:
                                           ; SOURCE LINE # 1428
0000 2000FD      R     JB      RS_Xbusy,?C0085
0003         ?C0086:
                                           ; SOURCE LINE # 1430
0003 C2AC              CLR     SFR_ES
                                           ; SOURCE LINE # 1431
0005 8F99              MOV     SFR_SBUF,R7
                                           ; SOURCE LINE # 1432
0007 D200        R     SETB    RS_Xbusy
                                           ; SOURCE LINE # 1433
0009 D2AC              SETB    SFR_ES
                                           ; SOURCE LINE # 1434
000B 22                RET     
             ; FUNCTION _RS_tx (END)

             ; FUNCTION _delay1ms (BEGIN)
                                           ; SOURCE LINE # 1456
;---- Variable 'cnt_1ms' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 1457
                                           ; SOURCE LINE # 1458
0000 E4                CLR     A
0001 F500        R     MOV     tic_pc,A
0003 F500        R     MOV     tic_pc+01H,A
0005         ?C0088:
                                           ; SOURCE LINE # 1460
0005 C3                CLR     C
0006 E500        R     MOV     A,tic_pc+01H
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 55  

0008 9F                SUBB    A,R7
0009 E500        R     MOV     A,tic_pc
000B 9E                SUBB    A,R6
000C 40F7              JC      ?C0088
000E         ?C0089:
                                           ; SOURCE LINE # 1461
000E         ?C0090:
000E 22                RET     
             ; FUNCTION _delay1ms (END)

             ; FUNCTION _delay1s (BEGIN)
                                           ; SOURCE LINE # 1466
;---- Variable 'line' assigned to Register 'R4/R5' ----
0000 900000      R     MOV     DPTR,#cnt_1s
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1467
                                           ; SOURCE LINE # 1469
0008 7BFF              MOV     R3,#0FFH
000A 7A00        R     MOV     R2,#HIGH ?SC_0
000C 7900        R     MOV     R1,#LOW ?SC_0
000E 900000      E     MOV     DPTR,#?_Printf?BYTE+03H
0011 EE                MOV     A,R6
0012 F0                MOVX    @DPTR,A
0013 A3                INC     DPTR
0014 EF                MOV     A,R7
0015 F0                MOVX    @DPTR,A
0016 AF05              MOV     R7,AR5
0018 A3                INC     DPTR
0019 EC                MOV     A,R4
001A F0                MOVX    @DPTR,A
001B A3                INC     DPTR
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
001E 120000      E     LCALL   _Printf
                                           ; SOURCE LINE # 1470
;---- Variable 'i' assigned to Register 'R4/R5' ----
0021 E4                CLR     A
0022 FD                MOV     R5,A
0023 FC                MOV     R4,A
0024         ?C0091:
0024 D3                SETB    C
0025 900000      R     MOV     DPTR,#cnt_1s+01H
0028 E0                MOVX    A,@DPTR
0029 9D                SUBB    A,R5
002A 900000      R     MOV     DPTR,#cnt_1s
002D E0                MOVX    A,@DPTR
002E 9C                SUBB    A,R4
002F 400E              JC      ?C0094
                                           ; SOURCE LINE # 1471
0031 7FE8              MOV     R7,#0E8H
0033 7E03              MOV     R6,#03H
0035 120000      R     LCALL   _delay1ms
                                           ; SOURCE LINE # 1472
0038 0D                INC     R5
0039 BD0001            CJNE    R5,#00H,?C0108
003C 0C                INC     R4
003D         ?C0108:
003D 80E5              SJMP    ?C0091
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 56  

                                           ; SOURCE LINE # 1473
003F         ?C0094:
003F 22                RET     
             ; FUNCTION _delay1s (END)

             ; FUNCTION _EnableInterrupt (BEGIN)
                                           ; SOURCE LINE # 1566
;---- Variable 'intrn' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1567
                                           ; SOURCE LINE # 1568
0000 7401              MOV     A,#01H
0002 A807              MOV     R0,AR7
0004 08                INC     R0
0005 8002              SJMP    ?C0110
0007         ?C0109:
0007 C3                CLR     C
0008 33                RLC     A
0009         ?C0110:
0009 D8FC              DJNZ    R0,?C0109
000B 42FB              ORL     SFR_E2IE,A
                                           ; SOURCE LINE # 1569
000D 22                RET     
             ; FUNCTION _EnableInterrupt (END)

             ; FUNCTION _DisableInterrupt (BEGIN)
                                           ; SOURCE LINE # 1573
;---- Variable 'intrn' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1574
                                           ; SOURCE LINE # 1575
0000 7401              MOV     A,#01H
0002 A807              MOV     R0,AR7
0004 08                INC     R0
0005 8002              SJMP    ?C0112
0007         ?C0111:
0007 C3                CLR     C
0008 33                RLC     A
0009         ?C0112:
0009 D8FC              DJNZ    R0,?C0111
000B F4                CPL     A
000C 52FB              ANL     SFR_E2IE,A
                                           ; SOURCE LINE # 1576
000E 22                RET     
             ; FUNCTION _DisableInterrupt (END)

             ; FUNCTION InitRemoTimer (BEGIN)
                                           ; SOURCE LINE # 1587
                                           ; SOURCE LINE # 1588
                                           ; SOURCE LINE # 1594
0000 E4                CLR     A
0001 F5C8              MOV     SFR_T2CON,A
                                           ; SOURCE LINE # 1596
0003 C2AD              CLR     SFR_ET2
                                           ; SOURCE LINE # 1597
0005 F5C9              MOV     SFR_T2IF,A
                                           ; SOURCE LINE # 1600
0007 75CDFF            MOV     SFR_TH2,#0FFH
000A 75CBFF            MOV     SFR_CRCH,#0FFH
                                           ; SOURCE LINE # 1601
000D 75CC2E            MOV     SFR_TL2,#02EH
0010 75CA2E            MOV     SFR_CRCL,#02EH
                                           ; SOURCE LINE # 1603
0013 75CC2D            MOV     SFR_TL2,#02DH
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 57  

0016 75CA2D            MOV     SFR_CRCL,#02DH
                                           ; SOURCE LINE # 1615
0019 75C812            MOV     SFR_T2CON,#012H
                                           ; SOURCE LINE # 1626
001C F500        R     MOV     RemoTic,A
001E 750004      R     MOV     RemoTic+01H,#04H
                                           ; SOURCE LINE # 1627
0021 D200        R     SETB    RemoPhase1
                                           ; SOURCE LINE # 1642
0023 7800        R     MOV     R0,#LOW RemoSystemCode
0025 F6                MOV     @R0,A
                                           ; SOURCE LINE # 1643
0026 18                DEC     R0
0027 F6                MOV     @R0,A
                                           ; SOURCE LINE # 1645
0028 D2AD              SETB    SFR_ET2
                                           ; SOURCE LINE # 1646
002A 22                RET     
             ; FUNCTION InitRemoTimer (END)

             ; FUNCTION InitCPU (BEGIN)
                                           ; SOURCE LINE # 1693
                                           ; SOURCE LINE # 1694
                                           ; SOURCE LINE # 1700
0000 E4                CLR     A
0001 F59A              MOV     TWBASE,A
                                           ; SOURCE LINE # 1702
0003 75E201            MOV     SFR_E2,#01H
                                           ; SOURCE LINE # 1735
0006 E500        R     MOV     A,regTW88+01H
0008 24E2              ADD     A,#0E2H
000A F582              MOV     DPL,A
000C E500        R     MOV     A,regTW88
000E 3404              ADDC    A,#04H
0010 F583              MOV     DPH,A
0012 7469              MOV     A,#069H
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1736
0015 E500        R     MOV     A,regTW88+01H
0017 24E3              ADD     A,#0E3H
0019 F582              MOV     DPL,A
001B E500        R     MOV     A,regTW88
001D 3404              ADDC    A,#04H
001F F583              MOV     DPH,A
0021 7478              MOV     A,#078H
0023 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1738
0024 E500        R     MOV     A,regTW88+01H
0026 24E4              ADD     A,#0E4H
0028 F582              MOV     DPL,A
002A E500        R     MOV     A,regTW88
002C 3404              ADDC    A,#04H
002E F583              MOV     DPH,A
0030 7401              MOV     A,#01H
0032 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1739
0033 E500        R     MOV     A,regTW88+01H
0035 24E5              ADD     A,#0E5H
0037 F582              MOV     DPL,A
0039 E500        R     MOV     A,regTW88
003B 3404              ADDC    A,#04H
003D F583              MOV     DPH,A
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 58  

003F 740E              MOV     A,#0EH
0041 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1741
0042 E500        R     MOV     A,regTW88+01H
0044 24E6              ADD     A,#0E6H
0046 F582              MOV     DPL,A
0048 E500        R     MOV     A,regTW88
004A 3404              ADDC    A,#04H
004C F583              MOV     DPH,A
004E E4                CLR     A
004F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1742
0050 E500        R     MOV     A,regTW88+01H
0052 24E7              ADD     A,#0E7H
0054 F582              MOV     DPL,A
0056 E500        R     MOV     A,regTW88
0058 3404              ADDC    A,#04H
005A F583              MOV     DPH,A
005C 741B              MOV     A,#01BH
005E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1744
005F E500        R     MOV     A,regTW88+01H
0061 24E8              ADD     A,#0E8H
0063 F582              MOV     DPL,A
0065 E500        R     MOV     A,regTW88
0067 3404              ADDC    A,#04H
0069 F583              MOV     DPH,A
006B E4                CLR     A
006C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1745
006D E500        R     MOV     A,regTW88+01H
006F 24E9              ADD     A,#0E9H
0071 F582              MOV     DPL,A
0073 E500        R     MOV     A,regTW88
0075 3404              ADDC    A,#04H
0077 F583              MOV     DPH,A
0079 740C              MOV     A,#0CH
007B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1747
007C E500        R     MOV     A,regTW88+01H
007E 24EA              ADD     A,#0EAH
0080 F582              MOV     DPL,A
0082 E500        R     MOV     A,regTW88
0084 3404              ADDC    A,#04H
0086 F583              MOV     DPH,A
0088 E4                CLR     A
0089 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1748
008A E500        R     MOV     A,regTW88+01H
008C 24EB              ADD     A,#0EBH
008E F582              MOV     DPL,A
0090 E500        R     MOV     A,regTW88
0092 3404              ADDC    A,#04H
0094 F583              MOV     DPH,A
0096 7418              MOV     A,#018H
0098 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1752
0099 E4                CLR     A
009A F58E              MOV     SFR_CKCON,A
                                           ; SOURCE LINE # 1763
009C 758966            MOV     SFR_TMOD,#066H
                                           ; SOURCE LINE # 1775
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 59  

009F 758855            MOV     SFR_TCON,#055H
                                           ; SOURCE LINE # 1785
00A2 758CFF            MOV     SFR_TH0,#0FFH
                                           ; SOURCE LINE # 1786
00A5 758AFF            MOV     SFR_TL0,#0FFH
                                           ; SOURCE LINE # 1794
00A8 758DCE            MOV     SFR_TH1,#0CEH
                                           ; SOURCE LINE # 1799
00AB 7587C0            MOV     SFR_PCON,#0C0H
                                           ; SOURCE LINE # 1809
00AE 759850            MOV     SFR_SCON,#050H
                                           ; SOURCE LINE # 1819
00B1 75C050            MOV     SFR_SCON1,#050H
                                           ; SOURCE LINE # 1829
00B4 75B802            MOV     SFR_IP,#02H
                                           ; SOURCE LINE # 1834
00B7 D2A8              SETB    SFR_EX0
                                           ; SOURCE LINE # 1835
00B9 D2A9              SETB    SFR_ET0
                                           ; SOURCE LINE # 1836
00BB C2AA              CLR     SFR_EX1
                                           ; SOURCE LINE # 1837
00BD C2AB              CLR     SFR_ET1
                                           ; SOURCE LINE # 1838
00BF C2AD              CLR     SFR_ET2
                                           ; SOURCE LINE # 1839
00C1 D2AC              SETB    SFR_ES
                                           ; SOURCE LINE # 1849
00C3 C2AE              CLR     SFR_ES1
                                           ; SOURCE LINE # 1851
00C5 D2AF              SETB    SFR_EA
                                           ; SOURCE LINE # 1855
00C7 C2E8              CLR     SFR_EINT2
                                           ; SOURCE LINE # 1856
00C9 C2E9              CLR     SFR_EINT3
                                           ; SOURCE LINE # 1860
00CB C2EA              CLR     SFR_EINT4
                                           ; SOURCE LINE # 1862
00CD C2EB              CLR     SFR_EINT5
                                           ; SOURCE LINE # 1863
00CF C2EC              CLR     SFR_EINT6
                                           ; SOURCE LINE # 1871
00D1 F5FA              MOV     SFR_E2IF,A
                                           ; SOURCE LINE # 1872
00D3 F5FB              MOV     SFR_E2IE,A
                                           ; SOURCE LINE # 1873
00D5 F5FC              MOV     SFR_E2IP,A
                                           ; SOURCE LINE # 1874
00D7 75FDFF            MOV     SFR_E2IM,#0FFH
                                           ; SOURCE LINE # 1875
00DA F5FE              MOV     SFR_E2IT,A
                                           ; SOURCE LINE # 1881
00DC 7BFF              MOV     R3,#0FFH
00DE 7A00        R     MOV     R2,#HIGH ?SC_13
00E0 7900        R     MOV     R1,#LOW ?SC_13
00E2 120000      E     LCALL   _Puts
                                           ; SOURCE LINE # 1885
00E5 7BFF              MOV     R3,#0FFH
00E7 7A00        R     MOV     R2,#HIGH ?SC_27
00E9 7900        R     MOV     R1,#LOW ?SC_27
00EB 120000      E     LCALL   _Puts
                                           ; SOURCE LINE # 1890
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 60  

00EE E4                CLR     A
00EF F5C8              MOV     SFR_T2CON,A
                                           ; SOURCE LINE # 1893
00F1 7BFF              MOV     R3,#0FFH
00F3 7A00        R     MOV     R2,#HIGH ?SC_40
00F5 7900        R     MOV     R1,#LOW ?SC_40
00F7 120000      E     LCALL   _Puts
                                           ; SOURCE LINE # 1894
00FA 759B01            MOV     SFR_CACHE_EN,#01H
                                           ; SOURCE LINE # 1908
00FD 30950B            JNB     P1_5,?C0099
                                           ; SOURCE LINE # 1910
                                           ; SOURCE LINE # 1912
0100 C2A8              CLR     SFR_EX0
                                           ; SOURCE LINE # 1913
0102 7BFF              MOV     R3,#0FFH
0104 7A00        R     MOV     R2,#HIGH ?SC_47
0106 7900        R     MOV     R1,#LOW ?SC_47
0108 120000      E     LCALL   _Printf
                                           ; SOURCE LINE # 1914
                                           ; SOURCE LINE # 1915
010B         ?C0099:
010B 22                RET     
             ; FUNCTION InitCPU (END)

             ; FUNCTION _InitISR (BEGIN)
                                           ; SOURCE LINE # 1923
;---- Variable 'flag' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1924
                                           ; SOURCE LINE # 1926
0000 900000      R     MOV     DPTR,#i
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1929
0005 850082      R     MOV     DPL,regTW88+01H
0008 850083      R     MOV     DPH,regTW88
000B A3                INC     DPTR
000C A3                INC     DPTR
000D E0                MOVX    A,@DPTR
000E 850082      R     MOV     DPL,regTW88+01H
0011 850083      R     MOV     DPH,regTW88
0014 A3                INC     DPTR
0015 A3                INC     DPTR
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1930
0017 E500        R     MOV     A,regTW88+01H
0019 2404              ADD     A,#04H
001B F582              MOV     DPL,A
001D E4                CLR     A
001E 3500        R     ADDC    A,regTW88
0020 F583              MOV     DPH,A
0022 E0                MOVX    A,@DPTR
0023 5407              ANL     A,#07H
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1931
0026 D2A8              SETB    SFR_EX0
                                           ; SOURCE LINE # 1933
0028 C28B              CLR     SFR_IE1
                                           ; SOURCE LINE # 1938
002A E5FA              MOV     A,SFR_E2IF
002C 30E203            JNB     ACC.2,?C0100
                                           ; SOURCE LINE # 1939
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 61  

002F 75FA04            MOV     SFR_E2IF,#04H
0032         ?C0100:
                                           ; SOURCE LINE # 1940
0032 E4                CLR     A
0033 7800        R     MOV     R0,#LOW RemoDataReady
0035 F6                MOV     @R0,A
0036 43FB04            ORL     SFR_E2IE,#04H
                                           ; SOURCE LINE # 1942
0039 020000      E     LJMP    InitTouch
             ; FUNCTION _InitISR (END)

C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 62  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


InitCPU. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
SFR_SCON . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
timer0_int . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
DWORD. . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
SFR_TMOD . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0089H  1
SFR_TCON . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0088H  1
timer1_int . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  diff . . . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0000H  2
  TX . . . . . . . . . . . . . . . . .  STATIC   XDATA  U_INT    0000H  2
  TY . . . . . . . . . . . . . . . . .  STATIC   XDATA  U_INT    0002H  2
  TscData. . . . . . . . . . . . . . .  * REG *  DATA   U_INT    000AH  2
  temp . . . . . . . . . . . . . . . .  STATIC   XDATA  U_INT    0004H  2
watchdog_int . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
timer2_int . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   000FH  1
  sample . . . . . . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
_InitISR . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  flag . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
CpuTouchX. . . . . . . . . . . . . . .  PUBLIC   XDATA  U_INT    0006H  2
CpuTouchY. . . . . . . . . . . . . . .  PUBLIC   XDATA  U_INT    0008H  2
RemoDataReady. . . . . . . . . . . . .  PUBLIC   IDATA  U_CHAR   0000H  1
CpuTouchPressed. . . . . . . . . . . .  PUBLIC   DATA   BIT      0000H  1
SFR_IE1. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008BH  1
_DisableInterrupt. . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  intrn. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
INT_STATUS2_ACC. . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0000H  1
RemoDataCode . . . . . . . . . . . . .  PUBLIC   IDATA  U_CHAR   0001H  1
P1_2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
SFR_ET0. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A9H  1
SFR_ES1. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AEH  1
P1_5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
SFR_CACHE_EN . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009BH  1
SFR_ET1. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ABH  1
SFR_ET2. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ADH  1
SFR_TH0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008CH  1
SFR_EX0. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A8H  1
SFR_TH1. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008DH  1
SFR_EX1. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AAH  1
SFR_TH2. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CDH  1
uart0_int. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
OsdTimerClock. . . . . . . . . . . . .  PUBLIC   DATA   U_LONG   0001H  4
RemoSystemCode . . . . . . . . . . . .  PUBLIC   IDATA  U_CHAR   0002H  1
InitTouch. . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
SFR_TL0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008AH  1
RS_ready . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_EnableInterrupt . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  intrn. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
SFR_TL2. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CCH  1
ext1_intr_flag . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   000AH  1
tic01. . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0005H  1
RS_Xbusy . . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0001H  1
_delay1ms. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  cnt_1ms. . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
_Puts. . . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
ext0_int . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
SFR_EINT2. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E8H  1
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 63  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


ext1_int . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
InitRemoTimer. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
VH_Loss_Changed. . . . . . . . . . . .  PUBLIC   DATA   U_INT    0006H  2
SFR_EINT3. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E9H  1
ext2_int . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  val. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
SFR_EINT4. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EAH  1
SFR_SCON1. . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C0H  1
ext3_int . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
INT_STATUS . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0008H  1
SFR_EINT5. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EBH  1
ext4_int . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
SFR_EINT6. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ECH  1
SFR_T2CON. . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
ext5_int . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
CpuZ1. . . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_INT    000BH  2
BYTE . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
ext6_int . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
CpuZ2. . . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_INT    000DH  2
_PCMODEDATA. . . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  25
  support. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  han. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0001H  2
  van. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0003H  2
  vfreq. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  htotal . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0006H  2
  vtotal . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0008H  2
  hsyncpol . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   000AH  1
  vsyncpol . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   000BH  1
  hstart . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    000CH  2
  vstart . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    000EH  2
  offseth. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0010H  2
  offsetv. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0012H  2
  dummy0 . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0014H  1
  dummy1 . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0015H  1
  dummy2 . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0016H  2
  dummy3 . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0018H  1
ext7_int . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
RemoTic. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0009H  2
_delay1s . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  cnt_1s . . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0000H  2
  line . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
ext8_int . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
ext9_int . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
IntCount . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_LONG   000FH  4
RemoPhase1 . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0002H  1
RemoPhase2 . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0003H  1
SFR_CKCON. . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008EH  1
WORD . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
RM_get . . . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0004H  1
SFR_E2 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E2H  1
RS_buf . . . . . . . . . . . . . . . .  PUBLIC   DATA   ARRAY    000BH  32
TWBASE . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009AH  1
CpuAUX0. . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_INT    0013H  2
SFR_WDCON. . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D8H  1
CpuAUX1. . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_INT    0015H  2
CpuAUX2. . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_INT    0017H  2
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 64  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


CpuAUX3. . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_INT    0019H  2
CpuTouchStep . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   001BH  1
EXINT_STATUS . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   002BH  1
SPIIMAGE . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  16
  start. . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0004H  4
  left . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0008H  2
  top. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    000AH  2
  right. . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    000CH  2
  bottom . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    000EH  2
SFR_EA . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AFH  1
SFR_E2IE . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FBH  1
SFR_E2IF . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FAH  1
RemoReceivedTime . . . . . . . . . . .  PUBLIC   IDATA  U_LONG   0003H  4
RS0_Xbusy. . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0005H  1
CpuTouchSkipCount. . . . . . . . . . .  PUBLIC   XDATA  U_INT    001CH  2
tic_task . . . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    002CH  2
CpuAUX0_Changed. . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   001EH  1
SLIDEIMAGE . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  8
  start. . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0004H  4
CpuAUX1_Changed. . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   001FH  1
RegisterInfo . . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  6
  Min. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  Max. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0002H  2
  Default. . . . . . . . . . . . . . .  MEMBER   -----  INT      0004H  2
CpuAUX2_Changed. . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0020H  1
SFR_E2IM . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FDH  1
CpuAUX3_Changed. . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0021H  1
INT_STATUS_ACC . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   002EH  1
regTW88. . . . . . . . . . . . . . . .  PUBLIC   DATA   PTR      002FH  2
RS_in. . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0031H  1
SFR_E2IP . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FCH  1
CpuTouchChanged. . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0022H  1
RS_out . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0032H  1
ext10_int. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
SFR_E2IT . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FEH  1
SFR_TA . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EBH  1
ext11_int. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
SFR_T2IF . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C9H  1
ext12_int. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
ext13_int. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
SFR_ES . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ACH  1
ext14_int. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
INT_STATUS2. . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0033H  1
SFR_IP . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
INT_STATUS3. . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0034H  1
SFR_RI . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
SFR_TI . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
LongRegisterInfo . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  6
  Min. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  Max. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0002H  2
  Default. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0004H  2
SFR_CRCH . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CBH  1
RS_rx. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ret. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
SFR_CRCL . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CAH  1
C51 COMPILER V9.00   CPU                                                                   05/31/2013 20:18:28 PAGE 65  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


_RS_tx . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  tx_buf . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
tic_pc . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0035H  2
_Printf. . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
SFR_EWDI . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EDH  1
SystemClock. . . . . . . . . . . . . .  PUBLIC   DATA   U_LONG   0037H  4
_RS_ungetch. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ch . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
MCU_INT_STATUS . . . . . . . . . . . .  PUBLIC   DATA   U_INT    003BH  2
SFR_SBUF . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
SFR_PCON . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0087H  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1946    ----
   CONSTANT SIZE    =     69    ----
   XDATA SIZE       =     35       6
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     61    ----
   IDATA SIZE       =      7    ----
   BIT SIZE         =      6       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
